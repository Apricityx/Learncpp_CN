{
  "recentFiles": [
    {
      "basename": "12-7-introduction-to-lambdas-anonymous-functions",
      "path": "docs/12-7-introduction-to-lambdas-anonymous-functions.md"
    },
    {
      "basename": "return-type-deduction",
      "path": "docs/return-type-deduction.md"
    },
    {
      "basename": "lambda",
      "path": "docs/lambda.md"
    },
    {
      "basename": "MOC",
      "path": "docs/MOC.md"
    },
    {
      "basename": "abbreviated function templates",
      "path": "docs/abbreviated function templates.md"
    },
    {
      "basename": "function-literal",
      "path": "docs/function-literal.md"
    },
    {
      "basename": "type deduction",
      "path": "docs/type deduction.md"
    },
    {
      "basename": "closure",
      "path": "docs/closure.md"
    },
    {
      "basename": "10-y-using-a-language-reference",
      "path": "docs/10-y-using-a-language-reference.md"
    },
    {
      "basename": "19-x-Chapter-19-comprehensive-quiz",
      "path": "docs/19-x-Chapter-19-comprehensive-quiz.md"
    },
    {
      "basename": "moc-onepage",
      "path": "docs/images/onepage/moc-onepage.md"
    },
    {
      "basename": "class-instance",
      "path": "docs/class-instance.md"
    },
    {
      "basename": "fixed-array",
      "path": "docs/fixed-array.md"
    },
    {
      "basename": "7-10-Break-and-continue",
      "path": "docs/7-10-Break-and-continue.md"
    },
    {
      "basename": "4-3-Object-sizes-and-the-sizeof-operator",
      "path": "docs/4-3-Object-sizes-and-the-sizeof-operator.md"
    },
    {
      "basename": "4-2-Void",
      "path": "docs/4-2-Void.md"
    },
    {
      "basename": "4-1-Introduction-to-fundamental-data-types",
      "path": "docs/4-1-Introduction-to-fundamental-data-types.md"
    },
    {
      "basename": "10-1-Introduction-to-program-defined-user-defined-types",
      "path": "docs/10-1-Introduction-to-program-defined-user-defined-types.md"
    },
    {
      "basename": "5-1-Operator-precedence-and-associativity",
      "path": "docs/5-1-Operator-precedence-and-associativity.md"
    },
    {
      "basename": "dynamic-initialization",
      "path": "docs/dynamic-initialization.md"
    },
    {
      "basename": "6-8-Why-non-const-global-variables-are-evil",
      "path": "docs/6-8-Why-non-const-global-variables-are-evil.md"
    },
    {
      "basename": "static-initialization",
      "path": "docs/static-initialization.md"
    },
    {
      "basename": "12-8-lambda-captures",
      "path": "docs/12-8-lambda-captures.md"
    },
    {
      "basename": "12-6-Ellipsis-and-why-to-avoid-them",
      "path": "docs/12-6-Ellipsis-and-why-to-avoid-them.md"
    },
    {
      "basename": "12-3-std-vector-capacity-and-stack-behavior",
      "path": "docs/12-3-std-vector-capacity-and-stack-behavior.md"
    },
    {
      "basename": "13-17-nested-types-in-classes",
      "path": "docs/13-17-nested-types-in-classes.md"
    },
    {
      "basename": "10-x-Chapter-10-comprehensive-quiz",
      "path": "docs/10-x-Chapter-10-comprehensive-quiz.md"
    },
    {
      "basename": "10-4-scoped-enumerations-enum-classes",
      "path": "docs/10-4-scoped-enumerations-enum-classes.md"
    },
    {
      "basename": "10-3-unscoped-enumeration-input-and-output",
      "path": "docs/10-3-unscoped-enumeration-input-and-output.md"
    },
    {
      "basename": "10-2-unscoped-enumerations",
      "path": "docs/10-2-unscoped-enumerations.md"
    },
    {
      "basename": "9-1-Introduction-to-compound-data-types",
      "path": "docs/9-1-Introduction-to-compound-data-types.md"
    },
    {
      "basename": "6-12-Using-declarations-and-using directives",
      "path": "docs/6-12-Using-declarations-and-using directives.md"
    },
    {
      "basename": "13-2-classes-and-class-members",
      "path": "docs/13-2-classes-and-class-members.md"
    },
    {
      "basename": "1-4-Variable-assignment-and-initialization",
      "path": "docs/1-4-Variable-assignment-and-initialization.md"
    },
    {
      "basename": "2-7-Forward-declarations-and-definitions",
      "path": "docs/2-7-Forward-declarations-and-definitions.md"
    },
    {
      "basename": "M-1-introduction-to-smart-pointers-and-move-semantics",
      "path": "docs/M-1-introduction-to-smart-pointers-and-move-semantics.md"
    },
    {
      "basename": "M-2-R-value-references",
      "path": "docs/M-2-R-value-references.md"
    },
    {
      "basename": "10-11-class-template-argument-deduction-and-deduction -guides",
      "path": "docs/10-11-class-template-argument-deduction-and-deduction -guides.md"
    },
    {
      "basename": "one-definition-rule",
      "path": "docs/one-definition-rule.md"
    },
    {
      "basename": "10-10-class-templates",
      "path": "docs/10-10-class-templates.md"
    },
    {
      "basename": "template-class-specialization",
      "path": "docs/template-class-specialization.md"
    },
    {
      "basename": "function-template",
      "path": "docs/function-template.md"
    },
    {
      "basename": "10-9-member-selection-with-pointers-and-references",
      "path": "docs/10-9-member-selection-with-pointers-and-references.md"
    },
    {
      "basename": "10-8-struct-passing-and-miscellany",
      "path": "docs/10-8-struct-passing-and-miscellany.md"
    },
    {
      "basename": "struct-padding",
      "path": "docs/struct-padding.md"
    },
    {
      "basename": "value-initialization",
      "path": "docs/value-initialization.md"
    },
    {
      "basename": "10-7-default-member-initialization",
      "path": "docs/10-7-default-member-initialization.md"
    },
    {
      "basename": "10-6-struct-aggregate-initialization",
      "path": "docs/10-6-struct-aggregate-initialization.md"
    },
    {
      "basename": "non-static-member-initialization",
      "path": "docs/non-static-member-initialization.md"
    },
    {
      "basename": "default-member-initializer",
      "path": "docs/default-member-initializer.md"
    }
  ],
  "omittedPaths": [],
  "maxLength": null
}
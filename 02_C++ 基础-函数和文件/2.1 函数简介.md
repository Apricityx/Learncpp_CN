> [!INFO] 原文信息：
> - 链接： [2.1 — Introduction to functions](https://www.learncpp.com/cpp-tutorial/introduction-to-functions/)
> - 作者：[_ALEX_](https://www.learncpp.com/author/Alex/ "View all posts by Alex")
> - 2021-12-23

# 2.1 函数简介
在上一章节中，我们将函数定义为一组顺序执行指令的合集。这个定义固然没错，但是它并没有表达出函数的重要性。 这里让我们重新定义函数：函数是一组为了完成某项任务而创建的可复用的顺序指令集合。

你已经知道了，任何都必须包含一个名为 `main` 的函数（程序开始执行的地方）。然而，如果将程序的所有代码都塞进 `main` 函数中，那么它无疑会变得越来越长，也越来越难以维护。而函数则提供了一种将程序分割成简短的、模块化的代码段的方式。这种方式的代码更加容易管理、容易测试，也更容易使用。C++ 标准库中包含了非常多的已经编写好的函数可供你使用。不过，使用自己编写的函数也是非常常见的情形，这些函数称为用户自定义函数。

我们可以考虑这样一种生活中的场景：当你在阅读的时候，突然想到要去打一个电话。此时你会将书签夹在书里，然后去打电话，然后在回到夹了书签的地方继续阅读。

C++ 函数也可以通过类似的方法去工作。当遇到函数调用的时候，程序会进入函数并顺序地执行其中各个语句。而所谓函数调用，实际上是一个表达式，它可以告诉 CPU 中断当前函数的执行而转去执行另外一个函数。此时 CPU 就会在当前的执行点”插入一个书签“，然后去执行另外的函数。当该函数执行完毕后，CPU 就会返回之前中断的点继续执行。

实施函数调用的函数，称为**主调函数(caller)**，而被它调用的函数称为**被调函数(callee 或 called function)**。

## 用户定义函数案例

首先，让我们熟悉一下定义函数的基本语法。在接下来的几节课中，用户定义函数都是如下形式：

```
return-type identifier() // identifier replaced with the name of your function
{
// Your code here
}
```

简单介绍一下其中四个主要元素：

- 在本课程中，我们会使用 `int`（对于 `main()` 函数）或 `void` （对于其他函数）作为函数的返回值类型（ `return-type`）。我们会在下一节课（[[2.2 Function return values (value-returning functions)]]）中介绍更多的返回值类型；
- 和变量一样，函数也有函数名。`identifier`就是你定义的函数的函数名；
- 标识符后面的括号告诉编译器这里是在定义一个函数；
- 花括号以及花括号内部的语句称为**函数体**。这里就是放置函数语句的的地方。

下面的代码展示了如何定义并使用一个函数：

```cpp
#include <iostream> // for std::cout

// 定义一个名为 doPrint() 的函数
void doPrint() // doPrint() 在本例中是被调函数
{
    std::cout << "In doPrint()\n";
}

// Definition of function main()
int main()
{
    std::cout << "Starting main()\n";
    doPrint(); // 中断 main() 函数并调用 doPrint()。main() 函数是主调函数
    std::cout << "Ending main()\n"; // 在 doPrint() 结束后执行该指令

    return 0;
}
```

上述代码的输出结果如下：

```
Starting main()
In doPrint()
Ending main()
```

This program begins execution at the top of function _main_, and the first line to be executed prints `Starting main()`.

The second line in _main_ is a function call to the function _doPrint_. We call function _doPrint_ by appending a pair of parentheses to the function name like such: `doPrint()`. Note that if you forget the parentheses, your program may not compile (and if it does, the function will not be called).

> [!Warning] 注意

Don’t forget to include parentheses () after the function’s name when making a function call.

Because a function call was made, execution of statements in _main_ is suspended, and execution jumps to the top of called function _doPrint_. The first (and only) line in _doPrint_ prints `In doPrint()`. When _doPrint_ terminates, execution returns back to the caller (here: function _main_) and resumes from the point where it left off. Consequently, the next statement executed in _main_ prints `Ending main()`.

## Calling functions more than once

One useful thing about functions is that they can be called more than once. Here’s a program that demonstrates this:

```cpp
#include <iostream> // for std::cout

void doPrint()
{
    std::cout << "In doPrint()\n";
}

// Definition of function main()
int main()
{
    std::cout << "Starting main()\n";
    doPrint(); // doPrint() called for the first time
    doPrint(); // doPrint() called for the second time
    std::cout << "Ending main()\n";

    return 0;
}
```

COPY

This program produces the following output:

```
Starting main()
In doPrint()
In doPrint()
Ending main()
```

Since _doPrint_ gets called twice by _main_, _doPrint_ executes twice, and _In doPrint()_ gets printed twice (once for each call).

## Functions calling functions calling functions

You’ve already seen that function _main_ can call another function (such as function _doPrint_ in the example above). Any function can call any other function. In the following program, function _main_ calls function _doA_, which calls function _doB_:

```cpp
#include <iostream> // for std::cout

void doB()
{
    std::cout << "In doB()\n";
}

void doA()
{
    std::cout << "Starting doA()\n";

    doB();

    std::cout << "Ending doA()\n";
}

// Definition of function main()
int main()
{
    std::cout << "Starting main()\n";

    doA();

    std::cout << "Ending main()\n";

    return 0;
}
```

This program produces the following output:

```
Starting main()
Starting doA()
In doB()
Ending doA()
Ending main()
```

## Nested functions are not supported

Unlike some other programming languages, in C++, functions cannot be defined inside other functions. The following program is not legal:

```cpp
#include <iostream>

int main()
{
    void foo() // Illegal: this function is nested inside function main()
    {
        std::cout << "foo!\n";
    }

    foo(); // function call to foo()
    return 0;
}
```

The proper way to write the above program is:

```cpp
#include <iostream>

void foo() // no longer inside of main()
{
    std::cout << "foo!\n";
}

int main()
{
    foo();
    return 0;
}
```

>[!INFO] 题外话
>“foo” is a meaningless word that is often used as a placeholder name for a function or variable when the name is unimportant to the demonstration of some concept. Such words are called [metasyntactic variables](https://en.wikipedia.org/wiki/Metasyntactic_variable) (though in common language they’re often called “placeholder names” since nobody can remember the term “metasyntactic variable”). Other common metasyntactic variables in C++ include “bar”, “baz”, and 3-letter words that end in “oo”, such as “goo”, “moo”, and “boo”).
>
>For those interested in etymology (how words evolve), [RFC 3092](https://datatracker.ietf.org/doc/html/rfc3092) is an interesting read.

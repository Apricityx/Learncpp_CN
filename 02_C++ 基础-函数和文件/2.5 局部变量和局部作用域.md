> [!INFO] 原文信息：
> - 链接： [2.5 — Introduction to local scope](https://www.learncpp.com/cpp-tutorial/introduction-to-local-scope/)
> - 作者：[_ALEX_](https://www.learncpp.com/author/Alex/ "View all posts by Alex")
> - 2022-5-21

# 2.5 局部变量和局部作用域

## 局部变量

函数的[[形参(parameters)]]和函数内部定义的变量一样，都是[[局部变量(local variable)]] (局部变量是和[[全局变量(global variable)]]相对的概念，在后面的课程中我们会介绍全局变量）。

```cpp
int add(int x, int y) // function parameters x and y are local variables
{
    int z{ x + y }; // z is a local variable too

    return z;
}
```

本节课将详细介绍[[局部变量(local variable)]]所具有的一些属性。

## 局部变量生命周期

在[[1.3 对象和变量]]中我们讨论了以形如 `int x;` 的方式定义变量是如何在语句执行时[[实例化(instantiated)]] 变量的。函数的[[形参(parameters)]]是在进入函数时被创建和初始化的，函数体内的函数则是在定义时创建并初始化的。

例如：

```cpp
int add(int x, int y) // x 和 y 在此处创建并初始化
{
    int z{ x + y }; // z 在此处被创建和初始化

    return z;
}
```

此时我们不经要问，”那么实例化的变量是在合适被销毁的呢？“。[[局部变量(local variable)]]是在**包含其定义的一组花括号的结尾**时销毁的，其销毁的顺序和定义顺序正好相反（对于[[形参(parameters)]]来说，则是在函数结束时销毁）。

```cpp
int add(int x, int y)
{
    int z{ x + y };

    return z;
} // z, y, and x destroyed here
```

正如人的生命周期被定义为其出生到死亡的这段时间一样，变量的[[生命周期(lifetime)]]指的是该变量被创建到被销毁的这段时间。注意，变量的创建和销毁都是在程序运行的时候发生的（称为[[运行时(runtime)]]），而不是在[[编译时(compile-time)]]发生的。因此，生命是一个运行时属性。

>[!INFO] 扩展阅读
>The above rules around creation, initialization, and destruction are guarantees. That is, objects must be created and initialized no later than the point of definition, and destroyed no earlier than the end of the set of the curly braces in which they are defined (or, for function parameters, at the end of the function).
>
>In actuality, the C++ specification gives compilers a lot of flexibility to determine when local variables are created and destroyed. Objects may be created earlier, or destroyed later for optimization purposes. Most often, local variables are created when the function is entered, and destroyed in the opposite order of creation when the function is exited. We’ll discuss this in more detail in a future lesson, when we talk about the call stack.

下面这段程序展示了有关变量 `x` 生命周期更复杂的情况：

```cpp
#include <iostream>

void doSomething()
{
    std::cout << "Hello!\n";
}

int main()
{
    int x{ 0 }; // x 的生命周期起点

    doSomething(); // 在函数调用期间，x 仍然存在

    return 0;
} // x 的生命周期终点
```

在上面的例子中，x 的生命周期从它的定义开始一直到 `main` 函数的末尾结束。这其中包含了函数 `doSomething` 执行的时间。

## 局部作用域

一个[[标识符(identifier)]]的[[作用域(scope)]]表明了该表示符在源码中能够被访问的位置。如果一个标识符可以被访问，则称其在作用域中。当一个标识符不能被访问时，则称其超出了作用域（Out of scope）。作用域是一个[[编译时(compile-time)]]属性，如果在标识符的作用域之外访问它，会导致编译错误。

局部变量的作用域从该变量的定义开始，在包含了该变量定义的一组花括号的结尾终止（对于函数[[形参(parameters)]]则在函数结尾终止）。这确保了变量在定义前不能被使用（[[即使编译器选择在此之前创建变量]]）。在一个函数中定义的局部变量，其作用域不能延伸到其他函数中。

下面的例子展示了变量 `x` 的作用域：

```cpp
#include <iostream>

// x 不在该函数的作用域
void doSomething()
{
    std::cout << "Hello!\n";
}

int main()
{
    // x 此时还不能被访问，因为还没有进入其作用域

    int x{ 0 }; // x 从此时进入作用域，随后可以在该函数中使用它

    doSomething();

    return 0;
} // x 作用域终止与此，此后不再能够被使用
```

在上面的程序中，变量 `x` 从其定义位置开始进入作用域，在 `main` 函数结束时离开其作用域。注意，变量 `x` 的作用域不会延伸到函数 `doSomething()` 中。这也一位置 `main` 函数调用 `doSomething` 和该该变量的作用域没有任何关系。

## “超出作用域” 和 “离开作用域”

术语[[超出作用域(out of scope)]] 和[[离开作用域(going out of scope)]]对于新手来说可能令人困惑。

标识符超出作用域表示其不能在代码中被访问。在上面的例子中，[[标识符(identifier)]] `x` 进入作用域的时间从其定义开始到 `main` 函数结尾为止。这段代码以外的代码中访问该标识符，都属于超出作用域。

术语离开作用域描述的对象则一般是某个对象而不是标识符。我们说一个变量会在实例化它作用域的结尾处（花括号结束处）离开作用域。在上面的例子中，[[对象(objec)]] `x` 会在 `main` 函数的结尾处离开作用域。

具备变量的生命周期会在其离开作用域时终止，局部变量会在此时被销毁。

注意，并不是所有类型的变量都会在其离开作用域时被销毁。我们会在将来的课程中介绍此类例子。

## 其他例子

下面这个例子稍微更复杂一定。请记住，生命周期是一个运行时属性，而作用域是编译时属性。虽然，我们在同一段代码中讨论两者，它们的出发点是不同的。

```cpp
#include <iostream>

int add(int x, int y) // x 和 y 在此处被创建并进入作用域
{
    // x 和 y 仅在该函数中可见/可用
    return x + y;
} // y 和 x 离开作用域并被销毁

int main()
{
    int a{ 5 }; // a 在此处被创建、初始化并进入作用域
    int b{ 6 }; // b 在此处被创建、初始化并进入作用域

    // a 和 b 只在该函数中可用
    std::cout << add(a, b) << '\n'; // calls function add() with x=5 and y=6

    return 0;
} // b 和 a 离开作用域并被销毁
```

函数形参 _x_ 和 _y_ 在 add函数被调用时创建，are created when the _add_ function is called, can only be seen/used within function _add_, and are destroyed at the end of _add_. Variables _a_ and _b_ are created within function _main_, can only be seen/used within function _main_, and are destroyed at the end of _main_.

To enhance your understanding of how all this fits together, let’s trace through this program in a little more detail. The following happens, in order:

- execution starts at the top of _main_
- _main_‘s variable _a_ is created and given value _5_
- _main_‘s variable _b_ is created and given value _6_
- function _add_ is called with values _5_ and _6_ for arguments
- _add_‘s variable _x_ is created and initialized with value _5_
- _add_‘s variable _y_ is created and initialized with value _6_
- _operator+_ evaluates expression _x + y_ to produce the value _11_
- _add_ copies the value _11_ back to caller _main_
- _add_‘s _y_ and _x_ are destroyed
- _main_ prints 11 to the console
- _main_ returns _0_ to the operating system
- _main_‘s _b_ and _a_ are destroyed

And we’re done.

Note that if function _add_ were to be called twice, parameters _x_ and _y_ would be created and destroyed twice -- once for each call. In a program with lots of functions and function calls, variables are created and destroyed often.

## Functional separation

In the above example, it’s easy to see that variables _a_ and _b_ are different variables from _x_ and _y_.

Now consider the following similar program:

```cpp
#include <iostream>

int add(int x, int y) // add's x and y are created and enter scope here
{
    // add's x and y are visible/usable within this function only
    return x + y;
} // add's y and x go out of scope and are destroyed here

int main()
{
    int x{ 5 }; // main's x is created, initialized, and enters scope here
    int y{ 6 }; // main's y is created, initialized, and enters scope here

    // main's x and y are usable within this function only
    std::cout << add(x, y) << '\n'; // calls function add() with x=5 and y=6

    return 0;
} // main's y and x go out of scope and are destroyed here
```

COPY

In this example, all we’ve done is change the names of variables _a_ and _b_ inside of function _main_ to _x_ and _y_. This program compiles and runs identically, even though functions _main_and _add_ both have variables named _x_ and _y_. Why does this work?

First, we need to recognize that even though functions _main_ and _add_ both have variables named _x_ and _y_, these variables are distinct. The _x_ and _y_ in function _main_ have nothing to do with the _x_ and _y_ in function _add_ -- they just happen to share the same names.

Second, when inside of function _main_, the names _x_ and _y_ refer to main’s locally scoped variables _x_ and _y_. Those variables can only be seen (and used) inside of _main_. Similarly, when inside function _add_, the names _x_ and _y_ refer to function parameters _x_ and _y_, which can only be seen (and used) inside of _add_.

In short, neither _add_ nor _main_ know that the other function has variables with the same names. Because the scopes don’t overlap, it’s always clear to the compiler which _x_ and _y_are being referred to at any time.

>[!TIP] 关键信息
>Names used for function parameters or variables declared in a function body are only visible within the function that declares them. This means local variables within a function can be named without regard for the names of variables in other functions. This helps keep functions independent.

We’ll talk more about local scope, and other kinds of scope, in a future chapter.

Where to define local variables

Local variables inside the function body should be defined as close to their first use as reasonable:

```cpp
#include <iostream>

int main()
{
    std::cout << "Enter an integer: ";
    int x{}; // x defined here
    std::cin >> x; // and used here

    std::cout << "Enter another integer: ";
    int y{}; // y defined here
    std::cin >> y; // and used here

    int sum{ x + y }; // sum defined here
    std::cout << "The sum is: " << sum << '\n'; // and used here

    return 0;
}
```

COPY

In the above example, each variable is defined just before it is first used. There’s no need to be strict about this -- if you prefer to swap lines 5 and 6, that’s fine.

> [!TIP] 最佳实践
> Define your local variables as close to their first use as reasonable.

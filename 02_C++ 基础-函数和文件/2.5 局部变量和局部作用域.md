> [!INFO] 原文信息：
> - 链接：[2.5 — Introduction to local scope](https://www.learncpp.com/cpp-tutorial/introduction-to-local-scope/)
> - 作者：[_ALEX_](https://www.learncpp.com/author/Alex/ "View all posts by Alex")  
> - 2022-5-21

# 2.5 局部变量和局部作用域

## 局部变量

函数的[[形参(parameters)]]和函数内部定义的变量一样，都是[[局部变量(local variable)]] (局部变量是和[[全局变量(global variable)]]相对的概念，在后面的课程中我们会介绍全局变量）。

```cpp
int add(int x, int y) // function parameters x and y are local variables
{
    int z{ x + y }; // z is a local variable too

    return z;
}
```

本节课将详细介绍[[局部变量(local variable)]]所具有的一些属性。

## 局部变量生命周期

在[[1.3 对象和变量]]中我们讨论了以形如`int x;`的方式定义变量是如何在语句执行时[[实例化(instantiated)]] 变量的。函数的[[形参(parameters)]]是在进入函数时被创建和初始化的，函数体内的函数则是在定义时创建并初始化的。

例如：

```cpp
int add(int x, int y) // x 和 y 在此处创建并初始化
{
    int z{ x + y }; // z 在此处被创建和初始化

    return z;
}
```

此时我们不经要问，”那么实例化的变量是在合适被销毁的呢？“。[[局部变量(local variable)]]是在**包含其定义的一组花括号的结尾**时销毁的，其销毁的顺序和定义顺序正好相反（对于[[形参(parameters)]]来说，则是在函数结束时销毁）。


```cpp
int add(int x, int y)
{
    int z{ x + y };

    return z;
} // z, y, and x destroyed here
```

正如人的生命周期被定义为其出生到死亡的这段时间一样，变量的声明周期指的是该变量被创建到被销毁的这段时间。注意，变量的创建和销毁都是在程序运行的时候发生的（称为[[运行时(runtime)]]），而不是在[[编译时(compile-time)]]发生的。因此，声明周期是一个运行时属性。

>[!INFO] 扩展阅读
>The above rules around creation, initialization, and destruction are guarantees. That is, objects must be created and initialized no later than the point of definition, and destroyed no earlier than the end of the set of the curly braces in which they are defined (or, for function parameters, at the end of the function).
>
>In actuality, the C++ specification gives compilers a lot of flexibility to determine when local variables are created and destroyed. Objects may be created earlier, or destroyed later for optimization purposes. Most often, local variables are created when the function is entered, and destroyed in the opposite order of creation when the function is exited. We’ll discuss this in more detail in a future lesson, when we talk about the call stack.

下面这段程序展示了有关变量 `x` 生命周期更复杂的情况：

```cpp
#include <iostream>

void doSomething()
{
    std::cout << "Hello!\n";
}

int main()
{
    int x{ 0 }; // x 的生命周期起点

    doSomething(); // 在函数调用期间，x 仍然存在

    return 0;
} // x 的生命周期终点
```


在上面的例子中，x的生命周期从它的定义开始一直到`main`函数的末尾结束。这其中包含了函数 `doSomething`执行的时间。

## 局部作用域

一个[[标识符(identifier)]]的[[作用域(scope)]]表明了该表示符在源码中能够被访问的位置。如果一个标识符可以被访问，则称其在作用域中。当一个标识符不能被访问时，则称其超出了作用域（Out of scope）。作用域是一个[[编译时(compile-time)]]属性，如果在标识符的作用域之外访问它，会导致编译错误。

局部变量的作用域从该变量的定义开始，在包含了该变量定义的一组花括号的结尾终止（对于函数[[形参(parameters)]]则在函数结尾终止）。这确保了变量在定义前不能被使用（[[即使编译器选择在此之前创建变量]]）。This ensures variables can not be used before the point of definition (even if the compiler opts to create them before then). Local variables defined in one function are also not in scope in other functions that are called.

Here’s a program demonstrating the scope of a variable named _x_:

```cpp
#include <iostream>

// x is not in scope anywhere in this function
void doSomething()
{
    std::cout << "Hello!\n";
}

int main()
{
    // x can not be used here because it's not in scope yet

    int x{ 0 }; // x enters scope here and can now be used within this function

    doSomething();

    return 0;
} // x goes out of scope here and can no longer be used
```

COPY

In the above program, variable _x_ enters scope at the point of definition and goes out of scope at the end of the _main_ function. Note that variable _x_ is not in scope anywhere inside of function _doSomething()_. The fact that function _main_ calls function _doSomething_ is irrelevant in this context.

## “Out of scope” vs “going out of scope”

The terms “out of scope” and “going out of scope” can be confusing to new programmers.

An identifier is “out of scope” anywhere it can not be accessed within the code. In the example above, the identifier `x` is in-scope from its point of definition to the end of the `main()` function. The identifier is out-of-scope outside of that code region.

The term “going out of scope” is typically applied to objects rather than identifiers. We say an object “goes out of scope” at the end of the scope (the end curly brace) in which the object was instantiated. In the example above, the object named `x` “goes out of scope” at the end of the function `main()`.

A local variable’s lifetime ends at the point where it “goes out of scope”, so local variables are destroyed at this point.

Note that not all types of variables are destroyed when they “go out of scope”. We’ll see examples of these in future lessons.

## 其他例子

Here’s a slightly more complex example. Remember, lifetime is a runtime property, and scope is a compile-time property, so although we are talking about both in the same program, they are enforced at different points.

```cpp
#include <iostream>

int add(int x, int y) // x and y are created and enter scope here
{
    // x and y are visible/usable within this function only
    return x + y;
} // y and x go out of scope and are destroyed here

int main()
{
    int a{ 5 }; // a is created, initialized, and enters scope here
    int b{ 6 }; // b is created, initialized, and enters scope here

    // a and b are usable within this function only
    std::cout << add(a, b) << '\n'; // calls function add() with x=5 and y=6

    return 0;
} // b and a go out of scope and are destroyed here
```

COPY

Parameters _x_ and _y_ are created when the _add_ function is called, can only be seen/used within function _add_, and are destroyed at the end of _add_. Variables _a_ and _b_ are created within function _main_, can only be seen/used within function _main_, and are destroyed at the end of _main_.

To enhance your understanding of how all this fits together, let’s trace through this program in a little more detail. The following happens, in order:

-   execution starts at the top of _main_
-   _main_‘s variable _a_ is created and given value _5_
-   _main_‘s variable _b_ is created and given value _6_
-   function _add_ is called with values _5_ and _6_ for arguments
-   _add_‘s variable _x_ is created and initialized with value _5_
-   _add_‘s variable _y_ is created and initialized with value _6_
-   _operator+_ evaluates expression _x + y_ to produce the value _11_
-   _add_ copies the value _11_ back to caller _main_
-   _add_‘s _y_ and _x_ are destroyed
-   _main_ prints 11 to the console
-   _main_ returns _0_ to the operating system
-   _main_‘s _b_ and _a_ are destroyed

And we’re done.

Note that if function _add_ were to be called twice, parameters _x_ and _y_ would be created and destroyed twice -- once for each call. In a program with lots of functions and function calls, variables are created and destroyed often.

## Functional separation

In the above example, it’s easy to see that variables _a_ and _b_ are different variables from _x_ and _y_.

Now consider the following similar program:

```cpp
#include <iostream>

int add(int x, int y) // add's x and y are created and enter scope here
{
    // add's x and y are visible/usable within this function only
    return x + y;
} // add's y and x go out of scope and are destroyed here

int main()
{
    int x{ 5 }; // main's x is created, initialized, and enters scope here
    int y{ 6 }; // main's y is created, initialized, and enters scope here

    // main's x and y are usable within this function only
    std::cout << add(x, y) << '\n'; // calls function add() with x=5 and y=6

    return 0;
} // main's y and x go out of scope and are destroyed here
```

COPY

In this example, all we’ve done is change the names of variables _a_ and _b_ inside of function _main_ to _x_ and _y_. This program compiles and runs identically, even though functions _main_and _add_ both have variables named _x_ and _y_. Why does this work?

First, we need to recognize that even though functions _main_ and _add_ both have variables named _x_ and _y_, these variables are distinct. The _x_ and _y_ in function _main_ have nothing to do with the _x_ and _y_ in function _add_ -- they just happen to share the same names.

Second, when inside of function _main_, the names _x_ and _y_ refer to main’s locally scoped variables _x_ and _y_. Those variables can only be seen (and used) inside of _main_. Similarly, when inside function _add_, the names _x_ and _y_ refer to function parameters _x_ and _y_, which can only be seen (and used) inside of _add_.

In short, neither _add_ nor _main_ know that the other function has variables with the same names. Because the scopes don’t overlap, it’s always clear to the compiler which _x_ and _y_are being referred to at any time.

>[!TIP] 关键信息
>Names used for function parameters or variables declared in a function body are only visible within the function that declares them. This means local variables within a function can be named without regard for the names of variables in other functions. This helps keep functions independent.

We’ll talk more about local scope, and other kinds of scope, in a future chapter.

Where to define local variables

Local variables inside the function body should be defined as close to their first use as reasonable:

```cpp
#include <iostream>

int main()
{
	std::cout << "Enter an integer: ";
	int x{}; // x defined here
	std::cin >> x; // and used here

	std::cout << "Enter another integer: ";
	int y{}; // y defined here
	std::cin >> y; // and used here

	int sum{ x + y }; // sum defined here
	std::cout << "The sum is: " << sum << '\n'; // and used here

	return 0;
}
```

COPY

In the above example, each variable is defined just before it is first used. There’s no need to be strict about this -- if you prefer to swap lines 5 and 6, that’s fine.

> [!TIP] 最佳实践
> Define your local variables as close to their first use as reasonable.
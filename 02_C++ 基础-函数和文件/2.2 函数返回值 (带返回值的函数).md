> [!INFO] 原文信息：
> - 链接： [2.2 — Function return values (value-returning functions)](https://www.learncpp.com/cpp-tutorial/function-return-values-value-returning-functions/)
> - 作者：[_ALEX_](https://www.learncpp.com/author/Alex/ "View all posts by Alex")
> - 2022-4-22

# 2.2 函数返回值 (带返回值的函数)

请考虑下面这个程序：

```cpp
#include <iostream>

int main()
{
    // get a value from the user
    std::cout << "Enter an integer: ";
    int num{};
    std::cin >> num;

    // print the value doubled
    std::cout << num << " doubled is: " << num * 2 << '\n';

    return 0;
}
```

这个程序从概念上将包含两部分：首先我们从用户获取一个输入，然后告诉用户该输入的两倍是多少。

虽然这个程序已经足够简单，没必要将其划分为多个函数，但如果我们执意要这么做呢？从用户获取输入是一个非常明确的任务，将其作为一个函数应该是很合适的。

因此，程序被修改成了下面这样：

```cpp
// This program doesn't work
#include <iostream>

void getValueFromUser()
{
     std::cout << "Enter an integer: ";
    int input{};
    std::cin >> input;
}

int main()
{
    getValueFromUser(); // Ask user for input

    int num{}; // How do we get the value from getValueFromUser() and use it to initialize this variable?

    std::cout << num << " doubled is: " << num * 2 << '\n';

    return 0;
}
```

尽管看上去上面的尝试没什么问题，但实际上它却不能正常工作。

当函数 `getValueFromUser` 被调用时，程序会要求用户输入一个整型数，这符合我们的预期。但是当函数 `getValueFromUser` 调用结束并返回 `main` 函数时，刚才输入的值就被丢弃了。变量 `num` 始终都没有被初始化为用户输入的值，因此输出结果始终是 `0`。

问题出在 `getValueFromUser` 函数返回到 `main` 函数的时候，我们没有将用户输入的值一起返回，因此 `main` 函数就无法使用该值。

## 返回值

在编写函数的时候，我们需要确定该函数是否应该返回一个值给主调函数。如果需要，有两件事需要去做。

首先，必须指定函数返回值的类型，函数返回值类型的定义位于函数名前面。在上面的例子中，`getValueFromUser` 函数的返回值类型为 `void`（表示无需返回任何值给主调函数），而 `main` 函数的返回值类型则为 `int` （即返回一个 `int` 类型的值给主调函数）。注意，这里并不是定义返回的具体是什么值，而仅是指定其*类型*。

>[!INFO] 相关内容
>返回值为 `void` 类型的函数将在下节课中介绍（[[2.3 Void 函数 (无返回值函数)]]）

其次，在需要返回值的函数中，需要通过 `return` 语句来指定要返回的具体值。该具体值称为函数的**返回值**。当 `return` 语句被执行时，函数会立即退出，同时将返回值*拷贝*给主调函数。这个过程称为**值返回**（return by value）。

以下面这个简单的函数为例，它返回一个整型值：

```cpp
#include <iostream>

// int 是返回值类型
// 返回值类型为 int 意味着函数会返回某个整型值给主调函数（具体是什么值并不会在此处指定）
int returnFive()
{
    // return 语句指定了要返回的具体值
    return 5; // 返回 5 给主调函数
}

int main()
{
    std::cout << returnFive() << '\n'; // prints 5
    std::cout << returnFive() + 2 << '\n'; // prints 7

    returnFive(); // 函数返回了 5，但是该值被忽略了，因为没有使用该值做任何事情

    return 0;
}
```

函数执行结果如下：

```
5
7
```

代码执行从 `main` 的顶部开始执行，第一条语句对 `returnFive` 进行了求值，即调用了该函数。函数 `returnFive` 返回值为 5，该值返回给主调函数后，通过 `std:: cout` 被打印到控制台。

在第二处函数调用，语句 `returnFive` 进行了求值， 其结果就是 `returnFive` 函数再次被调用。函数仍然将返回值 5 返回给了主调函数。表达式 `5 + 2` 的求值结果是 7，随后该值通过 `std:: cout` 被打印到了控制台。

第三条语句再次调用了 `returnFive` 函数，其返回值仍然被返回给了主调函数，但是 `main` 函数并没有对该返回值进行任何操作，因此什么事情都没有发生（返回值被忽略了）。

注意：除非主调函数通过 `std:: cout` 将返回值发送到控制台进行打印，否则该值并不会被打印。在上面的例子中，最后一次调用函数时，主调函数没有将返回值发送到 `std:: cout`，因此其结果没有打印。

> [!TIP] 小贴士
> 当被调函数返回值是，主调函数可以决定是否在表达式或者语句中使用该返回值（例如：将其赋值给某个变量或将其发送到 `std:: cout`），也可以忽略它（不对返回值做任何操作）。

## 修改程序

有了上面的知识，我们可以对课程开始时的程序进行适当的修改：

```cpp
#include <iostream>

int getValueFromUser() // this function now returns an integer value
{
     std::cout << "Enter an integer: ";
    int input{};
    std::cin >> input;

    return input; // return the value the user entered back to the caller
}

int main()
{
    int num { getValueFromUser() }; // 使用 getValueFromUser() 的返回值对 num 进行初始化

    std::cout << num << " doubled is: " << num * 2 << '\n';

    return 0;
}
```

当上述程序开始执行时，`main`函数中的第一条语句会创建一个 `int`  类型的变量 `num`。当程序准备要对 `num`  初始化时，它会发现此处有一个函数调用`getValueFromUser()`，因此它会跳转去执行该函数。函数 `getValueFromUser` 要求用户输入一个值，然后它将该输入值返回给主调函数(`main`)。该返回值被用来对变量 `num` 进行初始化。

请自行编译该函数并运行其几次以确保其正常工作。

## Returning to main

You now have the conceptual tools to understand how the `main` function actually works. When the program is executed, the operating system makes a function call to `main`. Execution then jumps to the top of `main`. The statements in `main` are executed sequentially. Finally, `main` returns an integer value (usually `0`), and your program terminates. The return value from `main` is sometimes called a status code (also sometimes called an exit code, or rarely a return code), as it is used to indicate whether the program ran successfully or not.

By definition, a status code of `0` means the program executed successfully.

> [!TIP] 最佳实践
> Your `main` function should return the value `0` if the program ran normally.

A non-zero status code is often used to indicate failure (and while this works fine on most operating systems, strictly speaking, it’s not guaranteed to be portable).

>[!INFO] 扩展阅读
> C++标准中值定义了三种返回状态码：0、`EXIT_SUCCESS 和 ` `EXIT_FAILURE`。0 和 `EXIT_SUCCESS` 都表示程序执行成功。`EXIT_FAILURE`则表示程序没有成功执行。

`EXIT_SUCCESS` 和 `EXIT_FAILURE` 在  `<cstdlib>` 头文件中声明：

```cpp
#include <cstdlib> // for EXIT_SUCCESS and EXIT_FAILURE

int main()
{
    return EXIT_SUCCESS;
}
```


If you want to maximize portability, you should only use 0 or EXIT_SUCCESS to indicate a successful termination, or EXIT_FAILURE to indicate an unsuccessful termination.

C++ disallows calling the `main` function explicitly.

For now, you should also define your `main` function at the bottom of your code file, below other functions.

## A value-returning function that does not return a value will produce undefined behavior

A function that returns a value is called a value-returning function. A function is value-returning if the return type is anything other than `void`.

A value-returning function _must_ return a value of that type (using a return statement), otherwise undefined behavior will result.

>[!INFO] 相关内容
 We discuss undefined behavior in lesson [[1.6 未初始化的变量和未定义行为]]。

Here’s an example of a function that produces undefined behavior:

```cpp
#include <iostream>

int getValueFromUser() // this function returns an integer value
{
     std::cout << "Enter an integer: ";
    int input{};
    std::cin >> input;

    // note: no return statement
}

int main()
{
    int num { getValueFromUser() }; // initialize num with the return value of getValueFromUser()

    std::cout << num << " doubled is: " << num * 2 << '\n';

    return 0;
}
```

A modern compiler should produce a compile error because `getValueFromUser` is defined as returning an `int` but no return statement is provided. However, if the program did compile, running it would produce undefined behavior, because `getValueFromUser()` is a value-returning function that does not return a value.

In most cases, compilers will detect if you’ve forgotten to return a value. However, in some complicated cases, the compiler may not be able to properly determine whether your function returns a value or not in all cases, so you should not rely on this.

> [!TIP] 最佳实践
> Make sure your functions with non-void return types return a value in all cases.
> 
> Failure to return a value from a value-returning function will cause undefined behavior.

## Function main will implicitly return 0 if no return statement is provided

The only exception to the rule that a value-returning function must return a value via a return statement is for function `main()`. The function `main()` will implicitly return the value `0` if no return statement is provided. That said, it is best practice to explicitly return a value from `main`, both to show your intent, and for consistency with other functions (which will not let you omit the return value).

## Functions can only return a single value

A value-returning function can only return a single value back to the caller each time it is called.

Note that the value provided in a return statement doesn’t need to be literal -- it can be the result of any valid expression, including a variable or even a call to another function that returns a value. In the `getValueFromUser()` example above, we returned a variable `input`, which held the number the user input.

There are various ways to work around the limitation of functions only being able to return a single value, which we’ll cover in future lessons.

## The function author can decide what the return value means

The meaning of the value returned by a function is determined by the function’s author. Some functions use return values as status codes, to indicate whether they succeeded or failed. Other functions return a calculated or selected value. Other functions return nothing (we’ll see examples of these in the next lesson).

Because of the wide variety of possibilities here, it’s a good idea to document your function with a comment indicating what the return values mean. For example:

```cpp
// Function asks user to enter a value
// Return value is the integer entered by the user from the keyboard
int getValueFromUser()
{
     std::cout << "Enter an integer: ";
    int input{};
    std::cin >> input;

    return input; // return the value the user entered back to the caller
}
```

## Reusing functions

Now we can illustrate a good case for function reuse. Consider the following program:

```cpp
#include <iostream>

int main()
{
    int x{};
    std::cout << "Enter an integer: ";
    std::cin >> x;

    int y{};
    std::cout << "Enter an integer: ";
    std::cin >> y;

    std::cout << x << " + " << y << " = " << x + y << '\n';

    return 0;
}
```


While this program works, it’s a little redundant. In fact, this program violates one of the central tenets of good programming: Don’t Repeat Yourself (often abbreviated DRY).

Why is repeated code bad? If we wanted to change the text “Enter an integer:” to something else, we’d have to update it in two locations. And what if we wanted to initialize 10 variables instead of 2? That would be a lot of redundant code (making our programs longer and harder to understand), and a lot of room for typos to creep in.

Let’s update this program to use our `getValueFromUser` function that we developed above:

```cpp
#include <iostream>

int getValueFromUser()
{
     std::cout << "Enter an integer: ";
    int input{};
    std::cin >> input;

    return input;
}

int main()
{
    int x{ getValueFromUser() }; // first call to getValueFromUser
    int y{ getValueFromUser() }; // second call to getValueFromUser

    std::cout << x << " + " << y << " = " << x + y << '\n';

    return 0;
}
```


This program produces the following output:

```
Enter an integer: 5
Enter an integer: 7
5 + 7 = 12
```
In this program, we call `getValueFromUser` twice, once to initialize variable `x`, and once to initialize variable `y`. That saves us from duplicating the code to get user input, and reduces the odds of making a mistake. Once we know `getValueFromUser` works, we can call it as many times as we desire.

This is the essence of modular programming: the ability to write a function, test it, ensure that it works, and then know that we can reuse it as many times as we want and it will continue to work (so long as we don’t modify the function -- at which point we’ll have to retest it).

> [!TIP] 最佳实践
> Follow the DRY best practice: “don’t repeat yourself”. If you need to do something more than once, consider how to modify your code to remove as much redundancy as possible. Variables can be used to store the results of calculations that need to be used more than once (so we don’t have to repeat the calculation). Functions can be used to define a sequence of statements we want to execute more than once. And loops (which we’ll cover in a later chapter) can be used to execute a statement more than once.

>[!INFO] 题外话
> DRY 的反义词是 WET (“Write everything twice”——任何代码都写两遍).

> [!INFO] 原文信息：
> - 链接： [2.4 — Introduction to function parameters and arguments](https://www.learncpp.com/cpp-tutorial/introduction-to-function-parameters-and-arguments/)
> - 作者：[_ALEX_](https://www.learncpp.com/author/Alex/ "View all posts by Alex")
> - 2022-4-15

# 2.4 — 函数的形参和实参

在之前的课程中，我们了解到函数可以将值返回给主调函数，基于此，我们创建了 `getValueFromUser` 函数并用于下面这段程序：

```cpp
#include <iostream>

int getValueFromUser()
{
     std::cout << "Enter an integer: ";
    int input{};
    std::cin >> input;

    return input;
}

int main()
{
    int num { getValueFromUser() };

    std::cout << num << " doubled is: " << num * 2 << '\n';

    return 0;
}
```

不过，如果我们希望将输出语句也封装成一个函数呢？你可能希望这么做：

```cpp
#include <iostream>

int getValueFromUser()
{
     std::cout << "Enter an integer: ";
    int input{};
    std::cin >> input;

    return input;
}

// 这个函数不能编译
void printDouble()
{
    std::cout << num << " doubled is: " << num * 2 << '\n';
}

int main()
{
    int num { getValueFromUser() };

    printDouble();

    return 0;
}
```

这段程序并不能正确编译，因为 `printDouble` 并不知道 `num` 是什么。此时你或许会在 `printDouble()` 中定义 `num`：

```cpp
void printDouble()
{
    int num{}; // 添加此行
    std::cout << num << " doubled is: " << num * 2 << '\n';
}
```

尽管这么做可以避免编译器报错并使得程序成功编译，但该程序的运行结果并不正确（始终会打印：“0 doubled is: 0”）。这个问题的根本原因是 `printDouble` 无法访问用户的输入结果。

我们需要通过某种方式，将变量传递到 `printDouble` 函数内部，使其可以在函数体内使用该变量。

## 函数形参和实参

很多时候，我们希望能够在调用函数时将信息一并传入，这样该函数就可以基于此数据进行接下来的工作。例如，如果你希望编写一个计算两数和的函数，那么你必须有办法告诉在调用函数时，告诉函数需要相加的两个数。 否则，函数如何才能知道要将什么相加呢？通过函数的形参（parameters）和实参（arguments）可以完成上述工作。

函数的**形参**是能够在函数内部使用的变量。形参和函数内部定义的变量几乎是完全一样的，除了：形参总是由主调函数初始化并提供给被调函数。

函数的形参是在函数声明时定义的，它们位于函数名后的括号中，多个形参则由逗号隔开。

下面的例子中展示了包含不同数量形参的函数：

```cpp
// 函数没有参数
// 不依赖与主调函数提供任何值
void doPrint()
{
    std::cout << "In doPrint()\n";
}

// 函数接受一个名为 x 的整型参数
// 主调函数需要提供 x 的值
void printValue(int x)
{
    std::cout << x  << '\n';
}

// 函数接受两个参数，一个名为 x，一个名为 y
// 主调函数必须提供 x 和 y 的值
int add(int x, int y)
{
    return x + y;
}
```

**实参**指的是函数被调用时，主调函数传递给被调函数的值：

```cpp
doPrint(); // 没有实参
printValue(6); // 6 是传递给 printValue() 的实参
add(2, 3); // 2 和 3 是传递给 add() 的实参
```

注意，多个实参仍然由逗号进行分割。

## 形参和实参是如何协同工作的

当函数被调用时，所有的形参都被当做变量创建，然后所有的实参都被拷贝到对应的形参。这个过程称为**按值传递**（pass by value）。

例如：

```cpp
#include <iostream>

// This function has two integer parameters, one named x, and one named y
// The values of x and y are passed in by the caller
void printValues(int x, int y)
{
    std::cout << x << '\n';
    std::cout << y << '\n';
}

int main()
{
    printValues(6, 7); // This function call has two arguments, 6 and 7

    return 0;
}
```

当 `printValues` 函数使用实参 6 和 7 进行调用时，形参 x 被创建并初始化为 6，形参 y 被创建并初始化为 7。

上述代码输出结果如下：

```
6
7
```

注意，实参的个数必须和形参的个数保持一致，否则编译器就会报错。传递给函数的实参可以是任何合法的表达式（因为实参本质上只是形参的初始化值，而初始化值可以是任何合法表达式）。

## 修正错误的程序

现在，我们可以修正本节课开头的程序了：

```cpp
#include <iostream>

int getValueFromUser()
{
     std::cout << "Enter an integer: ";
    int input{};
    std::cin >> input;

    return input;
}

void printDouble(int value) // 函数现在有一个整型的形参
{
    std::cout << value << " doubled is: " << value * 2 << '\n';
}

int main()
{
    int num { getValueFromUser() };

    printDouble(num);

    return 0;
}
```

在上述程序中，变量 `num` 首先被初始化为用户输入的值。然后函数 `printDouble` 被调用，实参 `num` 被拷贝到形参。函数 `printDouble` 随后就可以使用该形参的值。

## 使用返回值作为实参

在上面的程序中，变量 `num` 只被使用了一次，我们可以将 `getValueFromUser` 的返回值作为 `printDouble` 的实参，将上面的代码稍加简化：

```cpp
#include <iostream>

int getValueFromUser()
{
     std::cout << "Enter an integer: ";
    int input{};
    std::cin >> input;

    return input;
}

void printDouble(int value)
{
    std::cout << value << " doubled is: " << value * 2 << '\n';
}

int main()
{
    printDouble(getValueFromUser());

    return 0;
}
```

现在, we’re using the return value of function _getValueFromUser_ directly as an argument to function _printDouble_!

Although this program is more concise (and makes it clear that the value read by the user will be used for nothing else), you may also find this “compact syntax” a bit hard to read. If you’re more comfortable sticking with the version that uses the variable instead, that’s fine.

## How parameters and return values work together

By using both parameters and a return value, we can create functions that take data as input, do some calculation with it, and return the value to the caller.

Here is an example of a very simple function that adds two numbers together and returns the result to the caller:

```cpp
#include <iostream>

// add() takes two integers as parameters, and returns the result of their sum
// The values of x and y are determined by the function that calls add()
int add(int x, int y)
{
    return x + y;
}

// main takes no parameters
int main()
{
    std::cout << add(4, 5) << '\n'; // Arguments 4 and 5 are passed to function add()
    return 0;
}
```

Execution starts at the top of _main_. When `add(4,5)` is evaluated, function _add_ is called, with parameter _x_ being initialized with value _4_, and parameter _y_ being initialized with value _5_.

The _return statement_ in function _add_ evaluates _x + y_ to produce the value _9_, which is then returned back to _main_. This value of _9_ is then sent to _std:: cout_ to be printed on the console.

Output:

```
9
```

In pictorial format:

![](https://www.learncpp.com/images/CppTutorial/Chapter2/ParametersReturn.png?ezimgfmt=rs:441x251/rscb2/ng: webp/ngcb2)

## 更多例子

Let’s take a look at some more function calls:

```cpp
#include <iostream>

int add(int x, int y)
{
    return x + y;
}

int multiply(int z, int w)
{
    return z * w;
}

int main()
{
    std::cout << add(4, 5) << '\n'; // within add() x=4, y=5, so x+y=9
    std::cout << add(1 + 2, 3 * 4) << '\n'; // within add() x=3, y=12, so x+y=15

    int a{ 5 };
    std::cout << add(a, a) << '\n'; // evaluates (5 + 5)

    std::cout << add(1, multiply(2, 3)) << '\n'; // evaluates 1 + (2 * 3)
    std::cout << add(1, add(2, 3)) << '\n'; // evaluates 1 + (2 + 3)

    return 0;
}
```

This program produces the output:

```
9
15
10
7
6
```

The first statement is straightforward.

In the second statement, the arguments are expressions that get evaluated before being passed. In this case, _1 + 2_ evaluates to _3_, so _3_ is copied to parameter _x_. _3 * 4_ evaluates to _12_, so _12_ is copied to parameter _y_. _add(3,12)_ resolves to _15_.

The next pair of statements is relatively easy as well:

```cpp
int a{ 5 };
std::cout << add(a, a) << '\n'; // evaluates (5 + 5)
```

In this case, _add()_ is called where the value of _a_ is copied into both parameters _x_ and _y_. Since _a_ has value _5_, _add(a, a)_ = _add(5,5)_, which resolves to value _10_.

Let’s take a look at the first tricky statement in the bunch:

```cpp
std::cout << add(1, multiply(2, 3)) << '\n'; // evaluates 1 + (2 * 3)
```

When the function _add_ is executed, the program needs to determine what the values for parameters _x_ and _y_ are. _x_ is simple since we just passed it the integer _1_. To get a value for parameter _y_, it needs to evaluate _multiply(2,3)_ first. The program calls _multiply_ and initializes _z_ = _2_and _w_ = _3_, so _multiply(2,3)_ returns the integer value _6_. That return value of _6_ can now be used to initialize the _y_ parameter of the _add_function. _add(1,6)_ returns the integer _7_, which is then passed to std:: cout for printing.

Put less verbosely:
```
add(1, multiply(2,3)) evaluates to add(1,6) evaluates to 7
```

The following statement looks tricky because one of the arguments given to _add_ is another call to _add_.

```cpp
std::cout << add(1, add(2, 3)) << '\n'; // evaluates 1 + (2 + 3)
```

But this case works exactly the same as the prior case. add(2,3) resolves first, resulting in the return value of _5_. Now it can resolve add(1,5), which evaluates to the value _6_, which is passed to std:: cout for printing.

Less verbosely:
```
add(1, add(2,3)) evaluates to add(1,5) => evaluates to 6
```

## Conclusion

Function parameters and return values are the key mechanisms by which functions can be written in a reusable way, as it allows us to write functions that can perform tasks and return retrieved or calculated results back to the caller without knowing what the specific inputs or outputs are ahead of time.

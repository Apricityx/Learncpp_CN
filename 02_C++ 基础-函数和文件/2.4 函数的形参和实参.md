> [!INFO] 原文信息：
> - 链接：[2.4 — Introduction to function parameters and arguments](https://www.learncpp.com/cpp-tutorial/introduction-to-function-parameters-and-arguments/)
> - 作者：[_ALEX_](https://www.learncpp.com/author/Alex/ "View all posts by Alex")  
> - 2022-4-15

# 2.4 — 函数的形参和实参

在之前的课程中，我们了解到函数可以将值返回给主调函数，基于此，我们创建了 `getValueFromUser` 函数并用于下面这段程序：

```cpp
#include <iostream>

int getValueFromUser()
{
 	std::cout << "Enter an integer: ";
	int input{};
	std::cin >> input;

	return input;
}

int main()
{
	int num { getValueFromUser() };

	std::cout << num << " doubled is: " << num * 2 << '\n';

	return 0;
}
```

COPY

However, what if we wanted to put the output line into its own function as well? You might try something like this:

```cpp
#include <iostream>

int getValueFromUser()
{
 	std::cout << "Enter an integer: ";
	int input{};
	std::cin >> input;

	return input;
}

// This function won't compile
void printDouble()
{
	std::cout << num << " doubled is: " << num * 2 << '\n';
}

int main()
{
	int num { getValueFromUser() };

	printDouble();

	return 0;
}
```

COPY

This won’t compile, because function _printDouble_ doesn’t know what identifier _num_ is. You might try defining num as a variable inside function printDouble():

```cpp
void printDouble()
{
	int num{}; // we added this line
	std::cout << num << " doubled is: " << num * 2 << '\n';
}
```

COPY

While this addresses the compiler error and makes the program compile-able, the program still doesn’t work correctly (it always prints “0 doubled is: 0”). The core of the problem here is that function _printDouble_ doesn’t have a way to access the value the user entered.

We need some way to pass the value of variable _num_ to function _printDouble_ so that _printDouble_ can use that value in the function body.

Function parameters and arguments

In many cases, it is useful to be able to pass information _to_ a function being called, so that the function has data to work with. For example, if we wanted to write a function to add two numbers, we need some way to tell the function which two numbers to add when we call it. Otherwise, how would the function know what to add? We do that via function parameters and arguments.

A function parameter is a variable used in a function. Function parameters work almost identically to variables defined inside the function, but with one difference: they are always initialized with a value provided by the caller of the function.

Function parameters are defined in the function declaration by placing them in between the parenthesis after the function identifier, with multiple parameters being separated by commas.

Here are some examples of functions with different numbers of parameters:

```cpp
// This function takes no parameters
// It does not rely on the caller for anything
void doPrint()
{
    std::cout << "In doPrint()\n";
}

// This function takes one integer parameter named x
// The caller will supply the value of x
void printValue(int x)
{
    std::cout << x  << '\n';
}

// This function has two integer parameters, one named x, and one named y
// The caller will supply the value of both x and y
int add(int x, int y)
{
    return x + y;
}
```

COPY

An argument is a value that is passed _from_ the caller _to_ the function when a function call is made:

```cpp
doPrint(); // this call has no arguments
printValue(6); // 6 is the argument passed to function printValue()
add(2, 3); // 2 and 3 are the arguments passed to function add()
```

COPY

Note that multiple arguments are also separated by commas.

How parameters and arguments work together

When a function is called, all of the parameters of the function are created as variables, and the value of each of the arguments is _copied_ into the matching parameter. This process is called pass by value.

For example:

```cpp
#include <iostream>

// This function has two integer parameters, one named x, and one named y
// The values of x and y are passed in by the caller
void printValues(int x, int y)
{
    std::cout << x << '\n';
    std::cout << y << '\n';
}

int main()
{
    printValues(6, 7); // This function call has two arguments, 6 and 7

    return 0;
}
```

COPY

When function _printValues_ is called with arguments _6_ and _7_, _printValues_‘s parameter _x_ is created and initialized with the value of _6_, and _printValues_‘s parameter _y_ is created and initialized with the value of _7_.

This results in the output:

6
7

Note that the number of arguments must generally match the number of function parameters, or the compiler will throw an error. The argument passed to a function can be any valid expression (as the argument is essentially just an initializer for the parameter, and initializers can be any valid expression).

Fixing our challenge program

We now have the tool we need to fix the program we presented at the top of the lesson:

```cpp
#include <iostream>

int getValueFromUser()
{
 	std::cout << "Enter an integer: ";
	int input{};
	std::cin >> input;

	return input;
}

void printDouble(int value) // This function now has an integer parameter
{
	std::cout << value << " doubled is: " << value * 2 << '\n';
}

int main()
{
	int num { getValueFromUser() };

	printDouble(num);

	return 0;
}
```

COPY

In this program, variable _num_ is first initialized with the value entered by the user. Then, function _printDouble_ is called, and the value of argument _num_ is copied into the _value_ parameter of function _printDouble_. Function _printDouble_ then uses the value of parameter _value_.

Using return values as arguments

In the above problem, we can see that variable _num_ is only used once, to transport the return value of function _getValueFromUser_ to the argument of the call to function _printDouble_.

We can simplify the above example slightly as follows:

```cpp
#include <iostream>

int getValueFromUser()
{
 	std::cout << "Enter an integer: ";
	int input{};
	std::cin >> input;

	return input;
}

void printDouble(int value)
{
	std::cout << value << " doubled is: " << value * 2 << '\n';
}

int main()
{
	printDouble(getValueFromUser());

	return 0;
}
```

COPY

Now, we’re using the return value of function _getValueFromUser_ directly as an argument to function _printDouble_!

Although this program is more concise (and makes it clear that the value read by the user will be used for nothing else), you may also find this “compact syntax” a bit hard to read. If you’re more comfortable sticking with the version that uses the variable instead, that’s fine.

How parameters and return values work together

By using both parameters and a return value, we can create functions that take data as input, do some calculation with it, and return the value to the caller.

Here is an example of a very simple function that adds two numbers together and returns the result to the caller:

```cpp
#include <iostream>

// add() takes two integers as parameters, and returns the result of their sum
// The values of x and y are determined by the function that calls add()
int add(int x, int y)
{
    return x + y;
}

// main takes no parameters
int main()
{
    std::cout << add(4, 5) << '\n'; // Arguments 4 and 5 are passed to function add()
    return 0;
}
```

COPY

Execution starts at the top of _main_. When `add(4, 5)` is evaluated, function _add_ is called, with parameter _x_ being initialized with value _4_, and parameter _y_ being initialized with value _5_.

The _return statement_ in function _add_ evaluates _x + y_ to produce the value _9_, which is then returned back to _main_. This value of _9_ is then sent to _std::cout_ to be printed on the console.

Output:

9

In pictorial format:

![](https://www.learncpp.com/images/CppTutorial/Chapter2/ParametersReturn.png?ezimgfmt=rs:441x251/rscb2/ng:webp/ngcb2)

More examples

Let’s take a look at some more function calls:

```cpp
#include <iostream>

int add(int x, int y)
{
    return x + y;
}

int multiply(int z, int w)
{
    return z * w;
}

int main()
{
    std::cout << add(4, 5) << '\n'; // within add() x=4, y=5, so x+y=9
    std::cout << add(1 + 2, 3 * 4) << '\n'; // within add() x=3, y=12, so x+y=15

    int a{ 5 };
    std::cout << add(a, a) << '\n'; // evaluates (5 + 5)

    std::cout << add(1, multiply(2, 3)) << '\n'; // evaluates 1 + (2 * 3)
    std::cout << add(1, add(2, 3)) << '\n'; // evaluates 1 + (2 + 3)

    return 0;
}
```

COPY

This program produces the output:

9
15
10
7
6

The first statement is straightforward.

In the second statement, the arguments are expressions that get evaluated before being passed. In this case, _1 + 2_ evaluates to _3_, so _3_ is copied to parameter _x_. _3 * 4_ evaluates to _12_, so _12_ is copied to parameter _y_. _add(3, 12)_ resolves to _15_.

The next pair of statements is relatively easy as well:

```cpp
int a{ 5 };
std::cout << add(a, a) << '\n'; // evaluates (5 + 5)
```

COPY

In this case, _add()_ is called where the value of _a_ is copied into both parameters _x_ and _y_. Since _a_ has value _5_, _add(a, a)_ = _add(5, 5)_, which resolves to value _10_.

Let’s take a look at the first tricky statement in the bunch:

```cpp
std::cout << add(1, multiply(2, 3)) << '\n'; // evaluates 1 + (2 * 3)
```

COPY

When the function _add_ is executed, the program needs to determine what the values for parameters _x_ and _y_ are. _x_ is simple since we just passed it the integer _1_. To get a value for parameter _y_, it needs to evaluate _multiply(2, 3)_ first. The program calls _multiply_ and initializes _z_ = _2_and _w_ = _3_, so _multiply(2, 3)_ returns the integer value _6_. That return value of _6_ can now be used to initialize the _y_ parameter of the _add_function. _add(1, 6)_ returns the integer _7_, which is then passed to std::cout for printing.

Put less verbosely:  
_add(1, multiply(2, 3))_ evaluates to _add(1, 6)_ evaluates to _7_

The following statement looks tricky because one of the arguments given to _add_ is another call to _add_.

```cpp
std::cout << add(1, add(2, 3)) << '\n'; // evaluates 1 + (2 + 3)
```

COPY

But this case works exactly the same as the prior case. add(2, 3) resolves first, resulting in the return value of _5_. Now it can resolve add(1, 5), which evaluates to the value _6_, which is passed to std::cout for printing.

Less verbosely:  
_add(1, add(2, 3))_ evaluates to _add(1, 5)_ => evaluates to _6_

Conclusion

Function parameters and return values are the key mechanisms by which functions can be written in a reusable way, as it allows us to write functions that can perform tasks and return retrieved or calculated results back to the caller without knowing what the specific inputs or outputs are ahead of time.
# 1.4 — Variable assignment and initialization

在上一节课  [[1.3 对象和变量]] 中，我们介绍了如何定义一个变量。在这一节课中，我们会介绍如何为变量赋值并使用它存储的值。

首先回忆一下，下面这个代码片段中，我们在内存中为一个名为 x 的整型变量分配了内存，然后类似地，又创建了两个整型变量，分别叫做 y 和 z：

```cpp
int x; // define an integer variable named x
int y, z; // define two integer variables, named y and z
```

## 变量赋值

变量创建完毕后，你可以使用运算符 `=` 为其赋值（在另外一个单独的语句中），这个操作称为拷贝赋值（或赋值）。

```cpp
int width; // define an integer variable named width
width = 5; // copy assignment of value 5 into variable width

// variable width now has value 5
```

拷贝赋值名字的来历，源于上述操作将赋值运算符右侧的值拷贝后赋值给了左侧的变量。`=` 称为赋值运算符。

下面的例子中，我们先后两次使用了赋值操作。

```cpp
#include <iostream>

int main()
{
	int width;
	width = 5; // copy assignment of value 5 into variable width

	// variable width now has value 5

	width = 7; // change value stored in variable width to 7

	// variable width now has value 7

	return 0;
}
```


在我们把 7 赋值给变量 `width` 的时候，之前的值（5）就被覆盖掉了。一般的变量只能够存储一个值。

>[!NOTE] Warning
> 新手程序员常犯的错误之一就是将赋值运算符(`=`)和相等比较运算符(`==`)弄混淆。赋值运算符用于给变量赋值，而相等比较运算符则用于校验两个操作数的值是否相等。



## 初始化

上述赋值过程的缺点之一，是它需要两条语句才能完成：首先定义变量，然后为变量赋值。

这两步其实是可以合并的。在定义变量的时候，我们可以为这个变量设置一个初始值，这个过程称为初始化。用于初始化变量的这个值，称为[[初始化值]]（initializer）。

C++ 中的初始化是出奇的复杂，这里向你展示一个简化后的版本。

在 C++ 中有4种基本的变量初始化方法：

```cpp
int a; // 无初始化值
int b = 5; // 在等号后放置初始化值
int c( 6 ); // 在括号中放置初始化值
int d { 7 }; // 在花括号中放置初始化值
```

你可能已经注意到了上述代码片段中额外的空格（例如 `int d{7};`）。是否使用这些空格来增强可读性，属于一种个人偏好。

## 默认初始化

在不提供任何初始化值的时候（例如上面例子中的变量 `a`），将进行默认初始化。在大多数情况下，默认初始化会导致变量存放一个不确定值（indeterminate）。相关内容我们会在[[1.6 未初始化值和未定义行为]]中进行介绍。

## 拷贝初始化

如果等号后面提供了初始化值，此时将进行拷贝初始化。拷贝初始化继承自C语言。

```cpp
int width = 5; // copy initialization of value 5 into variable width
```

和拷贝赋值很类似，拷贝初始化会将等号右边的值拷贝到左侧创建的变量。

对于上述简单类型 `int` 而言，拷贝初始化是非常高效的。然而，在处理复杂类型时，拷贝初始化则是低效的。

## 直接初始化

当我们将初始化值置于括号内时，将进行直接初始化。

```cpp
int width( 5 ); // direct initialization of value 5 into variable width
```

对于 `int` 这样的简单数据类型而言，拷贝初始化和直接初始化本质上几乎没什么区别。对于复杂类型的变量，直接初始化相对于拷贝初始化则更加高效。

## 括号初始化 Brace initialization

不幸的是，直接初始化并不适用于所有类型（例如初始化一个包含一个列表的对象）。为了提供更为一致的初始化机制，C++ 支持了基于花括号的括号初始化（也称为统一初始化或列表初始化）。

括号初始化有三种形式。

```cpp
int width { 5 }; // 直接括号初始化（推荐）
int height = { 6 }; // 拷贝括号初始化
int depth {}; // 值初始化（详见下节）
```

直接括号初始化和拷贝括号初始化几乎是完全一样的，但通常更推荐直接括号初始化。

括号初始化的一个额外hao'chuBrace initialization has the added benefit of disallowing “narrowing” conversions. 也就是说，如果你使用括号初始化去初始化一个变量时，初始化值并不能被”安全的“存储，编译器会抛出一个告警或错误。例如：

```cpp
int width { 4.5 }; // 错误: not all double values fit into an int
```

COPY

In the above snippet, we’re trying to assign a number (4.5) that has a fractional part (the .5 part) to an integer variable (which can only hold numbers without fractional parts). Copy and direct initialization would drop the fractional part, resulting in initialization of value 4 into variable _width_. However, with brace initialization, this will cause the compiler to issue an error (which is generally a good thing, because losing data is rarely desired). Conversions that can be done without potential data loss are allowed.

Best practice

Favor initialization using braces whenever possible.

Q: C++ provides copy, direct, and brace initialization, and copy assignment. Is there a direct or brace assignment?

No, C++ does not support a direct or brace assignment syntax.

Value initialization and zero initialization

When a variable is initialized with empty braces, value initialization takes place. In most cases, value initialization will initialize the variable to zero (or empty, if that’s more appropriate for a given type). In such cases where zeroing occurs, this is called zero initialization.

```cpp
int width {}; // zero initialization to value 0
```

COPY

Q: When should I initialize with { 0 } vs {}?

Use an explicit initialization value if you’re actually using that value.

```cpp
int x { 0 }; // explicit initialization to value 0
std::cout << x; // we're using that zero value
```

COPY

Use value initialization if the value is temporary and will be replaced.

```cpp
int x {}; // value initialization
std::cin >> x; // we're immediately replacing that value
```

COPY

Initialize your variables

Initialize your variables upon creation. You may eventually find cases where you want to ignore this advice for a specific reason (e.g. a performance critical section of code that uses a lot of variables), and that’s okay, as long the choice is made deliberately.

For more discussion on this topic, Bjarne Stroustrup (creator of C++) and Herb Sutter (C++ expert) make this recommendation themselves [here](https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#es20-always-initialize-an-object).

We explore what happens if you try to use a variable that doesn’t have a well-defined value in lesson [1.6 -- Uninitialized variables and undefined behavior](https://www.learncpp.com/cpp-tutorial/uninitialized-variables-and-undefined-behavior/).

Best practice

Initialize your variables upon creation.

Initializing multiple variables

In the last section, we noted that it is possible to define multiple variables _of the same type_ in a single statement by separating the names with a comma:

```cpp
int a, b;
```

COPY

We also noted that best practice is to avoid this syntax altogether. However, since you may encounter other code that uses this style, it’s still useful to talk a little bit more about it, if for no other reason than to reinforce some of the reasons you should be avoiding it.

You can initialize multiple variables defined on the same line:

```cpp
int a = 5, b = 6; // copy initialization
int c( 7 ), d( 8 ); // direct initialization
int e { 9 }, f { 10 }; // brace initialization (preferred)
```

COPY

Unfortunately, there’s a common pitfall here that can occur when the programmer mistakenly tries to initialize both variables by using one initialization statement:

```cpp
int a, b = 5; // wrong (a is not initialized!)

int a = 5, b = 5; // correct
```

COPY

In the top statement, variable “a” will be left uninitialized, and the compiler may or may not complain. If it doesn’t, this is a great way to have your program intermittently crash and produce sporadic results. We’ll talk more about what happens if you use uninitialized variables shortly.

The best way to remember that this is wrong is to consider the case of direct initialization or brace initialization:

```cpp
int a, b( 5 );
int c, d{ 5 };
```

COPY

This makes it seem a little more clear that the value 5 is only being used to initialize variable _b_ or _d_, not _a_ or _c_.
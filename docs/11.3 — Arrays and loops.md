---
title: 11.3 - 数组和循环
alias: 11.3 - 数组和循环
origin: /arrays-and-loops/
origin_title: "11.3 — Arrays and loops"
time: 2022-5-21
type: translation
tags:
- array
- loop
---

??? note "关键点速记"
	

考虑这样一种情况，如果需要计算一个班级学生的平均成绩的话，使用多个变量的话可以这样做: 

```cpp
int numStudents{ 5 };
int score0{ 84 };
int score1{ 92 };
int score2{ 76 };
int score3{ 81 };
int score4{ 56 };

int totalScore{ score0 + score1 + score2 + score3 + score4 };
auto averageScore{ static_cast<double>(totalScore) / numStudents };
```

真是不少变量啊——而这仅仅是计算5个学生的平均值! 想象一下如果是30个学生或150个学生，那得是多大的工作量啊。

另外，如果添加了一个新学生，则必须声明、初始化一个新变量，并将其添加到 `totalScore` 计算中。 每次修改旧代码时，都有引入错误的风险。  

使用数组提供了一个更好的解决方案:

```cpp
int scores[]{ 84, 92, 76, 81, 56 };
int numStudents{ static_cast<int>(std::size(scores)) }; // 需要 C++17 和 <iterator> 头文件
int totalScore{ scores[0] + scores[1] + scores[2] + scores[3] + scores[4] };
auto averageScore{ static_cast<double>(totalScore) / numStudents };
```

这么做的确可以大大减少声明变量的数量，但 `totalScore` 仍然需要单独列出每个数组元素。如上所述，改变学生人数意味着需要手动调整总成绩公式。

如果有一种方法可以循环我们的数组并直接计算 `totalScore` 就好了。

## 数组的循环遍历


在上一节课中我们介绍过，数组的下标不需要是一个常量值——它可以是一个变量。这意味着我们可以使用循环变量作为数组索引来循环遍历数组的所有元素，并对它们执行一些计算。这是非常常见的，数组和循环几乎总是形影不离地出现。使用循环来依次访问每个数组元素通常被称为[[iterating|遍历(iterating)]]数组。

使用 for 循环来重新编写上面的代码：

```cpp
constexpr int scores[]{ 84, 92, 76, 81, 56 };
constexpr int numStudents{ static_cast<int>(std::size(scores)) };
// const int numStudents{ sizeof(scores) / sizeof(scores[0]) }; // use this instead if not C++17 capable
int totalScore{ 0 };

// use a loop to calculate totalScore
for (int student{ 0 }; student < numStudents; ++student)
    totalScore += scores[student];

auto averageScore{ static_cast<double>(totalScore) / numStudents };
```

COPY

This solution is ideal in terms of both readability and maintenance. Because the loop does all of our array element accesses, the formulas adjust automatically to account for the number of elements in the array. This means the calculations do not have to be manually altered to account for new students, and we do not have to manually add the name of new array elements!

Here’s an example of using a loop to search an array in order to determine the best score in the class:

```cpp
#include <iostream>
#include <iterator> // for std::size

int main()
{
    // scores are 0 (worst) to 100 (best)
    constexpr int scores[]{ 84, 92, 76, 81, 56 };
    constexpr int numStudents{ static_cast<int>(std::size(scores)) };

    int maxScore{ 0 }; // keep track of our largest score
    for (int student{ 0 }; student < numStudents; ++student)
    {
        if (scores[student] > maxScore)
        {
            maxScore = scores[student];
        }
    }

    std::cout << "The best score was " << maxScore << '\n';

    return 0;
}
```

COPY

In this example, we use a non-loop variable called maxScore to keep track of the highest score we’ve seen. maxScore is initialized to 0 to represent that we have not seen any scores yet. We then iterate through each element of the array, and if we find a score that is higher than any we’ve seen before, we set maxScore to that value. Thus, maxScore always represents the highest score out of all the elements we’ve searched so far. By the time we reach the end of the array, maxScore holds the highest score in the entire array.

## Mixing loops and arrays

Loops are typically used with arrays to do one of three things:

1.  Calculate a value (e.g. average value, total value)
2.  Search for a value (e.g. highest value, lowest value).
3.  Reorganize the array (e.g. ascending order, descending order)

When calculating a value, a variable is typically used to hold an intermediate result that is used to calculate the final value. In the above example where we are calculating an average score, totalScore holds the total score for all the elements examined so far.

When searching for a value, a variable is typically used to hold the best candidate value seen so far (or the array index of the best candidate). In the above example where we use a loop to find the best score, maxScore is used to hold the highest score encountered so far.

Sorting an array is a bit more tricky, as it typically involves nested loops. We will cover sorting an array in the next lesson.

## Arrays and off-by-one errors

One of the trickiest parts of using loops with arrays is making sure the loop iterates the proper number of times. Off-by-one errors are easy to make, and trying to access an element that is larger than the length of the array can have dire consequences. Consider the following program:

```cpp
#include <iostream>
#include <iterator>

int main()
{
  constexpr int scores[]{ 84, 92, 76, 81, 56 };
  constexpr int numStudents{ static_cast<int>(std::size(scores)) };

  int maxScore{ 0 }; // keep track of our largest score
  for (int student{ 0 }; student <= numStudents; ++student)
  {
      if (scores[student] > maxScore)
      {
          maxScore = scores[student];
      }
  }

  std::cout << "The best score was " << maxScore << '\n';

  return 0;
}
```

COPY

The problem with this program is that the condition in the for loop is wrong! The array declared has 5 elements, indexed from `0` to `4`. However, this array loops from `0` to `5`. Consequently, on the last iteration, the array will execute this:

```cpp
if (scores[5] > maxScore)
{
    maxScore = scores[5];
}
```

COPY

But `scores[5]` is undefined! This can cause all sorts of issues, with the most likely being that `scores[5]` results in a garbage value. In this case, the probable result is that maxScore will be wrong.

However, imagine what would happen if we inadvertently assigned a value to `array[5]`! We might overwrite another variable (or part of it), or perhaps corrupt something -- these types of bugs can be very hard to track down!

Consequently, when using loops with arrays, always double-check your loop conditions to make sure you do not introduce off-by-one errors.
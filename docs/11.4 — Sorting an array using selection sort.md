---
title: 11.4 - 数组排序之选择排序
alias: 11.4 - 数组排序之选择排序
origin: /sorting-an-array-using-selection-sort/
origin_title: "11.4 — Sorting an array using selection sort"
time: 2022-4-8
type: translation
tags:
- array
- sort
---

??? note "关键点速记"
	
## 排序
数组排序是将数组中所有元素按特定顺序排列的过程。排序在很多时候都是有用的。例如，电子邮件程序通常需要按照收件时间顺序显示电子邮件，因为最新的电子邮件通常被认为当前需要关注的。当你打开你的联系人列表时，名字通常是按字母顺序排列的，因为这样更容易找到你要找的名字。这两个例子都涉及在显示数据之前对其进行排序。

对数组进行排序可以提高搜索数组的效率，不仅对人类，对计算机也是如此。例如，考虑这样一种情况，我们想知道一个名字是否出现在一个名字列表中。为了查看名称是否在列表中，我们必须检查数组中的每个元素，以确定名称是否出现。对于包含许多元素的数组，搜索所有元素的开销可能很大。

但是，现在假设我们的名称数组是按字母顺序排序的。在本例中，我们只需要搜索到在字母顺序上比我们要查找的名称大的名称。这时，如果我们还没有找到这个名字，我们就知道它不存在于数组的其他部分，因为我们在数组中没有看到的所有名字都保证在字母顺序上更大!

其实还有更好的算法来搜索排序数组。使用一个简单的算法，我们可以搜索一个包含1,000,000个元素的排序数组，只需要进行20次比较!当然，其缺点是对数组进行排序的代价相对较高，而且通常不值得为了快速搜索而对数组进行排序，除非您要多次搜索它。

在某些情况下，对数组进行排序后就不需要再搜索了。例如，我们想找到最好的考试成绩。如果数组是无序的，我们必须遍历数组中的每个元素，以找到最大的测试分数。如果列表是排序的，最好的测试分数将在第一个或最后一个位置(取决于我们是按升序还是降序排序)，所以我们根本不需要搜索!


## 排序的原理

排序通常是通过反复比较数组元素对来执行的，如果它们满足某些预定义的条件，则交换它们。根据使用的排序算法的不同，比较这些元素的顺序也不同。标准取决于列表将如何排序(例如，升序或降序)。

要交换两个元素，可以使用c++标准库中的`std::swap()`函数，该函数在`<utility>`头文件中定义。

```cpp
#include <iostream>
#include <utility>

int main()
{
    int x{ 2 };
    int y{ 4 };
    std::cout << "Before swap: x = " << x << ", y = " << y << '\n';
    std::swap(x, y); // swap the values of x and y
    std::cout << "After swap:  x = " << x << ", y = " << y << '\n';

    return 0;
}
```

程序打印结果如下：

```
Before swap: x = 2, y = 4
After swap:  x = 4, y = 2
```

注意，使用`swap`后，`x`和`y`的值就被交换了！

## 选择排序
有很多方法可以对数组进行排序。**选择排序**可能是最容易理解的排序，这使它很适合作为教学示例（尽管它的排序速度并不快）。

选择排序的步骤如下（从小到大排序）：

1.  Starting at array index 0, search the entire array to find the smallest value
2.  Swap the smallest value found in the array with the value at index 0
3.  Repeat steps 1 & 2 starting from the next index

In other words, we’re going to find the smallest element in the array, and swap it into the first position. Then we’re going to find the next smallest element, and swap it into the second position. This process will be repeated until we run out of elements.

Here is an example of this algorithm working on 5 elements. Let’s start with a sample array:

{ 30, 50, 20, 10, 40 }

First, we find the smallest element, starting from index 0:

{ 30, 50, 20, **10**, 40 }

We then swap this with the element at index 0:

{ **10**, 50, 20, **30**, 40 }

Now that the first element is sorted, we can ignore it. Now, we find the smallest element, starting from index 1:

{ _10_, 50, **20**, 30, 40 }

And swap it with the element in index 1:

{ _10_, **20**, **50**, 30, 40 }

Now we can ignore the first two elements. Find the smallest element starting at index 2:

{ _10_, _20_, 50, **30**, 40 }

And swap it with the element in index 2:

{ _10_, _20_, **30**, **50**, 40 }

Find the smallest element starting at index 3:

{ _10_, _20_, _30_, 50, **40** }

And swap it with the element in index 3:

{ _10_, _20_, _30_, **40**, **50** }

Finally, find the smallest element starting at index 4:

{ _10_, _20_, _30_, _40_, **50** }

And swap it with the element in index 4 (which doesn’t do anything):

{ _10_, _20_, _30_, _40_, **50** }

Done!

{ 10, 20, 30, 40, 50 }

Note that the last comparison will always be with itself (which is redundant), so we can actually stop 1 element before the end of the array.

## C++ 中的选择排序

Here’s how this algorithm is implemented in C++:

```cpp
#include <iostream>
#include <iterator>
#include <utility>

int main()
{
	int array[]{ 30, 50, 20, 10, 40 };
	constexpr int length{ static_cast<int>(std::size(array)) };

	// Step through each element of the array
	// (except the last one, which will already be sorted by the time we get there)
	for (int startIndex{ 0 }; startIndex < length - 1; ++startIndex)
	{
		// smallestIndex is the index of the smallest element we’ve encountered this iteration
		// Start by assuming the smallest element is the first element of this iteration
		int smallestIndex{ startIndex };

		// Then look for a smaller element in the rest of the array
		for (int currentIndex{ startIndex + 1 }; currentIndex < length; ++currentIndex)
		{
			// If we've found an element that is smaller than our previously found smallest
			if (array[currentIndex] < array[smallestIndex])
				// then keep track of it
				smallestIndex = currentIndex;
		}

		// smallestIndex is now the smallest element in the remaining array
                // swap our start element with our smallest element (this sorts it into the correct place)
		std::swap(array[startIndex], array[smallestIndex]);
	}

	// Now that the whole array is sorted, print our sorted array as proof it works
	for (int index{ 0 }; index < length; ++index)
		std::cout << array[index] << ' ';

	std::cout << '\n';

	return 0;
}
```

COPY

The most confusing part of this algorithm is the loop inside of another loop (called a **nested loop**). The outside loop (startIndex) iterates through each element one by one. For each iteration of the outer loop, the inner loop (currentIndex) is used to find the smallest element in the remaining array (starting from startIndex+1). smallestIndex keeps track of the index of the smallest element found by the inner loop. Then smallestIndex is swapped with startIndex. Finally, the outer loop (startIndex) advances one element, and the process is repeated.

Hint: If you’re having trouble figuring out how the above program works, it can be helpful to work through a sample case on a piece of paper. Write the starting (unsorted) array elements horizontally at the top of the paper. Draw arrows indicating which elements startIndex, currentIndex, and smallestIndex are indexing. Manually trace through the program and redraw the arrows as the indices change. For each iteration of the outer loop, start a new line showing the current state of the array.

Sorting names works using the same algorithm. Just change the array type from int to std::string, and initialize with the appropriate values.

## `std::sort`

Because sorting arrays is so common, the C++ standard library includes a sorting function named `std::sort`. `std::sort` lives in the `<algorithm>` header, and can be invoked on an array like so:

```cpp
#include <algorithm> // for std::sort
#include <iostream>
#include <iterator> // for std::size

int main()
{
	int array[]{ 30, 50, 20, 10, 40 };

	std::sort(std::begin(array), std::end(array));

	for (int i{ 0 }; i < static_cast<int>(std::size(array)); ++i)
		std::cout << array[i] << ' ';

	std::cout << '\n';

	return 0;
}
```


By default, std::sort sorts in ascending order using `operator<` to compare pairs of elements and swapping them if necessary (much like our selection sort example does above).

We’ll talk more about `std::sort` in a future chapter.
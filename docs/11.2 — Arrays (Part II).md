---
title: 11.2 - 数组（第二部分）
alias: 11.2 - 数组（第二部分）
origin: /arrays-part-ii/
origin_title: "11.2 — Arrays (Part II)"
time: 2022-6-15
type: translation
tags:
- array
---

??? note "关键点速记"
	- 使用[[列表初始化]]方式初始化数组 `int prime[5]{ 2, 3, 5, 7, 11 };`
		- 初始化列表中的元素个数超过数组能容纳的个数时会报错，少于时剩下的会被初始化为0
		- 初始化一个全 0 数组：`int prime[5]{};`
	- 如果省略初始化列表，则数组元素为未初始化状态，除非它们是 `class` 类型的。
	- 不论数组元素可以在没有初始化列表时会不会被默认初始化，都应当显式地初始化数组。
	- 使用列表初始化对数组初始化时，编译器可以自动计算数组长度，因此不需要声明数组的长度。
	- 可以添加了一个名为 `max_XXX 的额外枚举值。此枚举值在数组声明期间使用，以确保数组具有适当的长度(因为数组长度应该比最大索引大1)。这对于代码可读性非常重要，当我们添加新的枚举值时，数组将自动调整大小：
	- [[enum-class|枚举类(enum class)]]并不能隐式地转换为对应的整型
	- 使用普通枚举类型并将其放置在某个作用域中，比使用枚举类更好。
	- 数组是传地址不是传值，所以如果你想确保一个函数不会修改传递给它的数组元素，可以将数组设置为 `const` 
	- `<iterator>` 头文件中的`std:size()`函数可以用来判断数组的长度，但不能用于数组被当做参数传递的情形。


书接上文（ [[11.1 — Arrays (Part I)|11.1 - 数组（第一部分）]]）。

## 固定数组初始化

数组元素会被当做普通变量来对待，因此，它们在创建时默认是不初始化的。
 
“初始化”数组的方式之一，是逐个元素进行初始化：
 
```cpp
int prime[5]; // hold the first 5 prime numbers
prime[0] = 2;
prime[1] = 3;
prime[2] = 5;
prime[3] = 7;
prime[4] = 11;
```


不过，这么做很麻烦，几乎不可能用来初始化非常长的数组。不仅如此，与其说这是在初始化，倒不如说是在赋值。如果数组是 `const` 类型的话，赋值是行不通的。

幸好，我们可以使用[[initializer-list|初始化列表(initializer list)]]来初始化整个数组。下面例子中初始化的数组和上一个例子的”初始化“结果是完全一样的：

```cpp
int prime[5]{ 2, 3, 5, 7, 11 }; // use initializer list to initialize the fixed array
```

如果列表中初始化值的数量超过了数组所能容纳的数量，编译器将会报告一个错误。

但是，如果列表中初始化器的数量少于数组所能容纳的数量，则剩余的元素将被初始化为 `0`(或者，`0` 会被转换其他非整型的值——例如，对于 `double` 类型，`0` 会转换为`0.0`)。这被称为[[zero-initialization|零初始化(zero initialization)]]。

请看下面这个例子：

```cpp
#include <iostream>

int main()
{
    int array[5]{ 7, 4, 5 }; // only initialize first 3 elements

    std::cout << array[0] << '\n';
    std::cout << array[1] << '\n';
    std::cout << array[2] << '\n';
    std::cout << array[3] << '\n';
    std::cout << array[4] << '\n';

    return 0;
}
```

打印：

```
7
4
5
0
0
```

因此，要将数组中的所有元素初始化为 0，你可以这样做:


```cpp
// Initialize all elements to 0
int array[5]{ };

// Initialize all elements to 0.0
double array[5]{ };

// Initialize all elements to an empty string
std::string array[5]{ };
```


如果省略初始化列表，则数组元素为未初始化状态，除非它们是 `class` 类型的。

```cpp
// 未初始化
int array[5];

// 未初始化
double array[5];

// 初始化为空字符串
std::string array[5];
```


!!! success "最佳实践"

	不论数组元素可以在没有初始化列表时会不会被默认初始化，都应当显式地初始化数组。


## 省略数组长度

如果您使用初始化列表初始化一个固定长度数组，编译器可以自动计算出数组的长度，所以你可以省略数组长度的声明。

下面两行是等价的:

```cpp
int array[5]{ 0, 1, 2, 3, 4 }; // explicitly define the length of the array
int array[]{ 0, 1, 2, 3, 4 }; // let the initializer list set length of the array
```

这么做的好处可不仅仅是方便，同时可以避免你在修改了元素后还要更新数组长度声明。

## 数组和枚举

对于数组来说，践行代码即文档的最大障碍，就是整数索引无法向程序员提供关于索引含义的任何信息。假设一个有 `5` 个学生的班级:

```cpp
constexpr int numberOfStudents{5};
int testScores[numberOfStudents]{};
testScores[2] = 76;
```

`testScores[2]`表示的是谁的分数？我们看不出来！

解决这个问题的办法是使用枚举类型，每个枚举变量对应一个数组索引：

```cpp
enum StudentNames
{
    kenny, // 0
    kyle, // 1
    stan, // 2
    butters, // 3
    cartman, // 4
    max_students // 5
};

int main()
{
    int testScores[max_students]{}; // allocate 5 integers
    testScores[stan] = 76;

    return 0;
}
```

这样，每个数组元素所代表的含义就更加清晰了。注意，我们添加了一个名为 `max_students` 的额外枚举值。此枚举值在数组声明期间使用，以确保数组具有适当的长度(因为数组长度应该比最大索引大1)。这对于代码可读性非常重要，当我们添加新的枚举值时，数组将自动调整大小：

```cpp
enum StudentNames
{
    kenny, // 0
    kyle, // 1
    stan, // 2
    butters, // 3
    cartman, // 4
    wendy, // 5
    max_students // 6
};

int main()
{
    int testScores[max_students]{}; // allocate 6 integers
    testScores[stan] = 76; // still works

    return 0;
}
```

注意，这个技巧只有在你不需要手动修改枚举值对应的数值时才有用。

## 数组和枚举类

[[enum-class|枚举类(enum class)]]并不能隐式地转换为对应的整型，所以如果你尝试编写下面的代码：

```cpp
enum class StudentNames
{
    kenny, // 0
    kyle, // 1
    stan, // 2
    butters, // 3
    cartman, // 4
    wendy, // 5
    max_students // 6
};

int main()
{
    int testScores[StudentNames::max_students]{}; // allocate 6 integers
    testScores[StudentNames::stan] = 76;

    return 0;
}
```

你会得到一个编译错误。为了解决这个问题，你可以使用  `static_cast` 将枚举值转换为整型。

```cpp
int main()
{
    int testScores[static_cast<int>(StudentNames::max_students)]{}; // allocate 6 integers
    testScores[static_cast<int>(StudentNames::stan)] = 76;

    return 0;
}
```

不过，这么做显然很麻烦。所以，使用普通枚举类型并将其放置在某个作用域中，比使用枚举类更好。

```cpp
namespace StudentNames
{
    enum StudentNames
    {
        kenny, // 0
        kyle, // 1
        stan, // 2
        butters, // 3
        cartman, // 4
        wendy, // 5
        max_students // 6
    };
}

int main()
{
    int testScores[StudentNames::max_students]{}; // allocate 6 integers
    testScores[StudentNames::stan] = 76;

    return 0;
}
```


## 将数组传递给函数

虽然乍一看向函数传递数组和传递普通变量好像没什么区别，但在本质上，C++对传递数组的处理是不同的。

普通变量通过[[按值传递(pass by value)]]的方式传入函数——C++将实参的值复制到函数形参中。因为形参是一个副本，改变形参的值并不会改变原始实参的值。

但是，由于复制大型数组的开销非常大，所以C++在将数组传递给函数时不会复制数组。相反，它会传递*数组本身*。这样做的副作用是函数可以直接更改数组元素的值！

下面的例子说明了这个概念:

```cpp
#include <iostream>

void passValue(int value) // value 是实参的副本
{
    value = 99; // 修改 value 的值不会影响原值
}

void passArray(int prime[5]) // prime 是数组本身
{
    prime[0] = 11; // 修改 prime 元素的值会实际修改数组
    prime[1] = 7;
    prime[2] = 5;
    prime[3] = 3;
    prime[4] = 2;
}

int main()
{
    int value{ 1 };
    std::cout << "before passValue: " << value << '\n';
    passValue(value);
    std::cout << "after passValue: " << value << '\n';

    int prime[5]{ 2, 3, 5, 7, 11 };
    std::cout << "before passArray: " << prime[0] << " " << prime[1] << " " << prime[2] << " " << prime[3] << " " << prime[4] << '\n';
    passArray(prime);
    std::cout << "after passArray: " << prime[0] << " " << prime[1] << " " << prime[2] << " " << prime[3] << " " << prime[4] << '\n';

    return 0;
}
```


```
before passValue: 1
after passValue: 1
before passArray: 2 3 5 7 11
after passArray: 11 7 5 3 2
```


在上面的例子中，`value` 没有在 `main()` 被中改变，因为 `passValue()` 函数中的参数值是 `main()` 函数中变量值的副本，而不是实际的变量。然而，由于`passArray()`函数中的数组是数组本身，`passArray()`能够直接改变元素的值！

上述现象背后的原因，和 C++ 实现数组的方式有关，我们会在 [[11.8 — Pointers and arrays|11.8 - 指针和数组]]中进行详细介绍。现在你可以暂时认为这是语言中的一个”怪异“特性。

注意，如果你想确保一个函数不会修改传递给它的数组元素，你可以将数组设置为 `const` :


```cpp
// 即使 prime 是实际上数组，在函数中它也会被看做是常量。
void passArray(const int prime[5])
{
    // so each of these lines will cause a compile error!
    prime[0] = 11;
    prime[1] = 7;
    prime[2] = 5;
    prime[3] = 3;
    prime[4] = 2;
}
```


## 确定数组长度

`<iterator>` 头文件中的`std:size()`函数可以用来判断数组的长度。

例如：

```cpp
#include <iostream>
#include <iterator> // for std::size

int main()
{
    int array[]{ 1, 1, 2, 3, 5, 8, 13, 21 };
    std::cout << "The array has: " << std::size(array) << " elements\n";

    return 0;
}
```

打印：

```
The array has: 8 elements
```

注意，由于 C++ 函数传递数组的特殊性，上面的方法不能用于数组被传递到函数中的情形。

```cpp
#include <iostream>
#include <iterator>

void printSize(int array[])
{
    std::cout << std::size(array) << '\n'; // Error
}

int main()
{
    int array[]{ 1, 1, 2, 3, 5, 8, 13, 21 };
    std::cout << std::size(array) << '\n'; // will print the size of the array
    printSize(array);

    return 0;
}
```


`std::size()` 也可以用于其他类型的对象（例如`std::array`和`std::vector`）,and it will cause a compiler error if you try to use it on a fixed array that has been passed to a function! Note that std::size returns an unsigned value. If you need a signed value, you can either cast the result or, since C++20, use `std::size()` (stands for signed size).

`std::size()` was added in C++17. If you’re still using an old compiler, you have to use the sizeof operator instead. sizeof isn’t as easy to use `as std::size()` and there are a few things you have to watch out for. If you’re using a C++17-capable compiler, you can skip to section “Indexing an array out of range”.

The sizeof operator can be used on arrays, and it will return the total size of the array (array length multiplied by element size).

```cpp
#include <iostream>

int main()
{
    int array[]{ 1, 1, 2, 3, 5, 8, 13, 21 };
    std::cout << sizeof(array) << '\n'; // will print the size of the array multiplied by the size of an int
    std::cout << sizeof(int) << '\n';

    return 0;
}
```

COPY

On a machine with 4 byte integers and 8 byte pointers, this printed:

```
32
4
```

(You may get a different result if the size of your types are different).

One neat trick: we can determine the length of a fixed array by dividing the size of the entire array by the size of an array element:

```cpp
#include <iostream>

int main()
{
    int array[]{ 1, 1, 2, 3, 5, 8, 13, 21 };
    std::cout << "The array has: " << sizeof(array) / sizeof(array[0]) << " elements\n";

    return 0;
}
```

COPY

This printed

```
The array has: 8 elements
```

How does this work? First, note that the size of the entire array is equal to the array’s length multiplied by the size of an element. Put more compactly: `array size = array length * element size`.

Using algebra, we can rearrange this equation: `array length = array size / element size. sizeof(array)` is the array size, and `sizeof(array[0])` is the element size, so our equation becomes array `length = sizeof(array) / sizeof(array[0])`. We typically use array element 0 for the array element, since it’s the only element guaranteed to exist no matter what the array length is.

Note that this will only work if the array is a fixed-length array, and you’re doing this trick in the same function that array is declared in (we’ll talk more about why this restriction exists in a future lesson in this chapter).

When sizeof is used on an array that has been passed to a function, it doesn’t error out like `std::size()` does. Instead, it returns the size of a pointer.

```cpp
#include <iostream>

void printSize(int array[])
{
    std::cout << sizeof(array) / sizeof(array[0]) << '\n';
}

int main()
{
    int array[]{ 1, 1, 2, 3, 5, 8, 13, 21 };
    std::cout << sizeof(array) / sizeof(array[0]) << '\n';
    printSize(array);

    return 0;
}
```

COPY

Again assuming 8 byte pointers and 4 byte integers, this prints

``8
2``

Author’s note

A properly configured compiler should print a warning if you try to use sizeof() on an array that was passed to a function.

The calculation in main() was correct, but the sizeof() in printSize() returned 8 (the size of a pointer), and 8 divided by 4 is 2.

For this reason, be careful about using sizeof() on arrays!

Note: In common usage, the terms “array size” and “array length” are both most often used to refer to the array’s length (the size of the array isn’t useful in most cases, outside of the trick we’ve shown you above).

## Indexing an array out of range

Remember that an array of length N has array elements 0 through N-1. So what happens if you try to access an array with a subscript outside of that range?

Consider the following program:

```cpp
int main()
{
    int prime[5]{}; // hold the first 5 prime numbers
    prime[5] = 13;

    return 0;
}
```

COPY

In this program, our array is of length 5, but we’re trying to write a prime number into the 6th element (index 5).

C++ does _not_ do any checking to make sure that your indices are valid for the length of your array. So in the above example, the value of 13 will be inserted into memory where the 6th element would have been had it existed. When this happens, you will get undefined behavior -- for example, this could overwrite the value of another variable, or cause your program to crash.

Although it happens less often, C++ will also let you use a negative index, with similarly undesirable results.

!!! note "法则"

	When using arrays, ensure that your indices are valid for the range of your array!
---
title: 11.2 - 数组（第二部分）
alias: 11.2 - 数组（第二部分）
origin: /arrays-part-ii/
origin_title: "11.2 — Arrays (Part II)"
time: 2022-6-15
type: translation
tags:
- array
---

??? note "关键点速记"
	- 使用[[列表初始化]]方式初始化数组 `int prime[5]{ 2, 3, 5, 7, 11 };`
		- 初始化列表中的元素个数超过数组能容纳的个数时会报错，少于时剩下的会被初始化为0
		- 初始化一个全 0 数组：`int prime[5]{};`
	- 如果省略初始化列表，则数组元素为未初始化状态，除非它们是 `class` 类型的。
	- 不论数组元素可以在没有初始化列表时会不会被默认初始化，都应当显式地初始化数组。
	- 使用列表初始化对数组初始化时，编译器可以自动计算数组长度，因此不需要声明数组的长度。
	- 可以添加了一个名为 `max_XXX 的额外枚举值。此枚举值在数组声明期间使用，以确保数组具有适当的长度(因为数组长度应该比最大索引大1)。这对于代码可读性非常重要，当我们添加新的枚举值时，数组将自动调整大小：

书接上文（ [[11.1 — Arrays (Part I)|11.1 - 数组（第一部分）]]）。

## 固定数组初始化

数组元素会被当做普通变量来对待，因此，它们在创建时默认是不初始化的。
 
“初始化”数组的方式之一，是逐个元素进行初始化：
 
```cpp
int prime[5]; // hold the first 5 prime numbers
prime[0] = 2;
prime[1] = 3;
prime[2] = 5;
prime[3] = 7;
prime[4] = 11;
```


不过，这么做很麻烦，几乎不可能用来初始化非常长的数组。不仅如此，与其说这是在初始化，倒不如说是在赋值。如果数组是 `const` 类型的话，赋值是行不通的。

幸好，我们可以使用[[initializer-list|初始化列表(initializer list)]]来初始化整个数组。下面例子中初始化的数组和上一个例子的”初始化“结果是完全一样的：

```cpp
int prime[5]{ 2, 3, 5, 7, 11 }; // use initializer list to initialize the fixed array
```

如果列表中初始化值的数量超过了数组所能容纳的数量，编译器将会报告一个错误。

但是，如果列表中初始化器的数量少于数组所能容纳的数量，则剩余的元素将被初始化为 `0`(或者，`0` 会被转换其他非整型的值——例如，对于 `double` 类型，`0` 会转换为`0.0`)。这被称为[[zero-initialization|零初始化(zero initialization)]]。

请看下面这个例子：

```cpp
#include <iostream>

int main()
{
    int array[5]{ 7, 4, 5 }; // only initialize first 3 elements

    std::cout << array[0] << '\n';
    std::cout << array[1] << '\n';
    std::cout << array[2] << '\n';
    std::cout << array[3] << '\n';
    std::cout << array[4] << '\n';

    return 0;
}
```

打印：

```
7
4
5
0
0
```

因此，要将数组中的所有元素初始化为 0，你可以这样做:


```cpp
// Initialize all elements to 0
int array[5]{ };

// Initialize all elements to 0.0
double array[5]{ };

// Initialize all elements to an empty string
std::string array[5]{ };
```


如果省略初始化列表，则数组元素为未初始化状态，除非它们是 `class` 类型的。

```cpp
// 未初始化
int array[5];

// 未初始化
double array[5];

// 初始化为空字符串
std::string array[5];
```


!!! success "最佳实践"

	不论数组元素可以在没有初始化列表时会不会被默认初始化，都应当显式地初始化数组。


## 省略数组长度

如果您使用初始化列表初始化一个固定长度数组，编译器可以自动计算出数组的长度，所以你可以省略数组长度的声明。

下面两行是等价的:
```cpp
int array[5]{ 0, 1, 2, 3, 4 }; // explicitly define the length of the array
int array[]{ 0, 1, 2, 3, 4 }; // let the initializer list set length of the array
```

这么做的好处可不仅仅是方便，同时可以避免你在修改了元素后还要更新数组长度声明。

## 数组和枚举

对于数组来说，践行代码即文档的最大障碍，就是整数索引无法向程序员提供关于索引含义的任何信息。假设一个有5个学生的班级:


```cpp
constexpr int numberOfStudents{5};
int testScores[numberOfStudents]{};
testScores[2] = 76;
```

`testScores[2]`表示的是谁的分数？我们看不出来！

解决这个问题的办法是使用枚举类型，每个枚举变量对应一个数组索引：

```cpp
enum StudentNames
{
    kenny, // 0
    kyle, // 1
    stan, // 2
    butters, // 3
    cartman, // 4
    max_students // 5
};

int main()
{
    int testScores[max_students]{}; // allocate 5 integers
    testScores[stan] = 76;

    return 0;
}
```

这样，每个数组元素所代表的含义就更加清晰了。注意，我们添加了一个名为 `max_students` 的额外枚举值。此枚举值在数组声明期间使用，以确保数组具有适当的长度(因为数组长度应该比最大索引大1)。这对于代码可读性非常重要，当我们添加新的枚举值时，数组将自动调整大小：

```cpp
enum StudentNames
{
    kenny, // 0
    kyle, // 1
    stan, // 2
    butters, // 3
    cartman, // 4
    wendy, // 5
    max_students // 6
};

int main()
{
    int testScores[max_students]{}; // allocate 6 integers
    testScores[stan] = 76; // still works

    return 0;
}
```

注意，这个技巧只有在你不需要手动修改枚举值对应的数值时才有用。

## 数组和枚举类

[[enum-class|枚举类(enum class)]]并不能隐式地转换为对应的整型，所以如果你尝试编写下面的代码：

```cpp
enum class StudentNames
{
    kenny, // 0
    kyle, // 1
    stan, // 2
    butters, // 3
    cartman, // 4
    wendy, // 5
    max_students // 6
};

int main()
{
    int testScores[StudentNames::max_students]{}; // allocate 6 integers
    testScores[StudentNames::stan] = 76;

    return 0;
}
```

你会得到一个编译错误。为了解决这个问题，你可以使用  `static_cast` 将枚举值转换为整型。

```cpp
int main()
{
    int testScores[static_cast<int>(StudentNames::max_students)]{}; // allocate 6 integers
    testScores[static_cast<int>(StudentNames::stan)] = 76;

    return 0;
}
```

不过，这么做显然很麻烦。所以，使用普通枚举类型并将其放置在某个作用域中，比使用枚举类更好。

```cpp
namespace StudentNames
{
    enum StudentNames
    {
        kenny, // 0
        kyle, // 1
        stan, // 2
        butters, // 3
        cartman, // 4
        wendy, // 5
        max_students // 6
    };
}

int main()
{
    int testScores[StudentNames::max_students]{}; // allocate 6 integers
    testScores[StudentNames::stan] = 76;

    return 0;
}
```

COPY

## Passing arrays to functions

Although passing an array to a function at first glance looks just like passing a normal variable, underneath the hood, C++ treats arrays differently.

When a normal variable is passed by value, C++ copies the value of the argument into the function parameter. Because the parameter is a copy, changing the value of the parameter does not change the value of the original argument.

However, because copying large arrays can be very expensive, C++ does _not_ copy an array when an array is passed into a function. Instead, the _actual_array is passed. This has the side effect of allowing functions to directly change the value of array elements!

The following example illustrates this concept:

```cpp
#include <iostream>

void passValue(int value) // value is a copy of the argument
{
    value = 99; // so changing it here won't change the value of the argument
}

void passArray(int prime[5]) // prime is the actual array
{
    prime[0] = 11; // so changing it here will change the original argument!
    prime[1] = 7;
    prime[2] = 5;
    prime[3] = 3;
    prime[4] = 2;
}

int main()
{
    int value{ 1 };
    std::cout << "before passValue: " << value << '\n';
    passValue(value);
    std::cout << "after passValue: " << value << '\n';

    int prime[5]{ 2, 3, 5, 7, 11 };
    std::cout << "before passArray: " << prime[0] << " " << prime[1] << " " << prime[2] << " " << prime[3] << " " << prime[4] << '\n';
    passArray(prime);
    std::cout << "after passArray: " << prime[0] << " " << prime[1] << " " << prime[2] << " " << prime[3] << " " << prime[4] << '\n';

    return 0;
}
```

COPY

```
before passValue: 1
after passValue: 1
before passArray: 2 3 5 7 11
after passArray: 11 7 5 3 2
```

In the above example, value is not changed in main() because the parameter value in function passValue() was a copy of variable value in function main(), not the actual variable. However, because the parameter array in function passArray() is the actual array, passArray() is able to directly change the value of the elements!

Why this happens is related to the way arrays are implemented in C++, a topic we’ll revisit in lesson [11.8 -- Pointers and arrays](https://www.learncpp.com/cpp-tutorial/pointers-and-arrays/). For now, you can consider this as a quirk of the language.

As a side note, if you want to ensure a function does not modify the array elements passed into it, you can make the array const:

```cpp
// even though prime is the actual array, within this function it should be treated as a constant
void passArray(const int prime[5])
{
    // so each of these lines will cause a compile error!
    prime[0] = 11;
    prime[1] = 7;
    prime[2] = 5;
    prime[3] = 3;
    prime[4] = 2;
}
```

COPY

## Determining the length of an array

The `std::size()` function from the `<iterator>` header can be used to determine the length of arrays.

Here’s an example:

```cpp
#include <iostream>
#include <iterator> // for std::size

int main()
{
    int array[]{ 1, 1, 2, 3, 5, 8, 13, 21 };
    std::cout << "The array has: " << std::size(array) << " elements\n";

    return 0;
}
```

COPY

This prints:

```
The array has: 8 elements
```

Note that due to the way C++ passes arrays to functions, this will _not_ work for arrays that have been passed to functions!

```cpp
#include <iostream>
#include <iterator>

void printSize(int array[])
{
    std::cout << std::size(array) << '\n'; // Error
}

int main()
{
    int array[]{ 1, 1, 2, 3, 5, 8, 13, 21 };
    std::cout << std::size(array) << '\n'; // will print the size of the array
    printSize(array);

    return 0;
}
```

COPY

`std::size()` will work with other kinds of objects (such as std::array and `std::vector`), and it will cause a compiler error if you try to use it on a fixed array that has been passed to a function! Note that std::size returns an unsigned value. If you need a signed value, you can either cast the result or, since C++20, use `std::size()` (stands for signed size).

`std::size()` was added in C++17. If you’re still using an old compiler, you have to use the sizeof operator instead. sizeof isn’t as easy to use `as std::size()` and there are a few things you have to watch out for. If you’re using a C++17-capable compiler, you can skip to section “Indexing an array out of range”.

The sizeof operator can be used on arrays, and it will return the total size of the array (array length multiplied by element size).

```cpp
#include <iostream>

int main()
{
    int array[]{ 1, 1, 2, 3, 5, 8, 13, 21 };
    std::cout << sizeof(array) << '\n'; // will print the size of the array multiplied by the size of an int
    std::cout << sizeof(int) << '\n';

    return 0;
}
```

COPY

On a machine with 4 byte integers and 8 byte pointers, this printed:

```
32
4
```

(You may get a different result if the size of your types are different).

One neat trick: we can determine the length of a fixed array by dividing the size of the entire array by the size of an array element:

```cpp
#include <iostream>

int main()
{
    int array[]{ 1, 1, 2, 3, 5, 8, 13, 21 };
    std::cout << "The array has: " << sizeof(array) / sizeof(array[0]) << " elements\n";

    return 0;
}
```

COPY

This printed

```
The array has: 8 elements
```

How does this work? First, note that the size of the entire array is equal to the array’s length multiplied by the size of an element. Put more compactly: `array size = array length * element size`.

Using algebra, we can rearrange this equation: `array length = array size / element size. sizeof(array)` is the array size, and `sizeof(array[0])` is the element size, so our equation becomes array `length = sizeof(array) / sizeof(array[0])`. We typically use array element 0 for the array element, since it’s the only element guaranteed to exist no matter what the array length is.

Note that this will only work if the array is a fixed-length array, and you’re doing this trick in the same function that array is declared in (we’ll talk more about why this restriction exists in a future lesson in this chapter).

When sizeof is used on an array that has been passed to a function, it doesn’t error out like `std::size()` does. Instead, it returns the size of a pointer.

```cpp
#include <iostream>

void printSize(int array[])
{
    std::cout << sizeof(array) / sizeof(array[0]) << '\n';
}

int main()
{
    int array[]{ 1, 1, 2, 3, 5, 8, 13, 21 };
    std::cout << sizeof(array) / sizeof(array[0]) << '\n';
    printSize(array);

    return 0;
}
```

COPY

Again assuming 8 byte pointers and 4 byte integers, this prints

``8
2``

Author’s note

A properly configured compiler should print a warning if you try to use sizeof() on an array that was passed to a function.

The calculation in main() was correct, but the sizeof() in printSize() returned 8 (the size of a pointer), and 8 divided by 4 is 2.

For this reason, be careful about using sizeof() on arrays!

Note: In common usage, the terms “array size” and “array length” are both most often used to refer to the array’s length (the size of the array isn’t useful in most cases, outside of the trick we’ve shown you above).

## Indexing an array out of range

Remember that an array of length N has array elements 0 through N-1. So what happens if you try to access an array with a subscript outside of that range?

Consider the following program:

```cpp
int main()
{
    int prime[5]{}; // hold the first 5 prime numbers
    prime[5] = 13;

    return 0;
}
```

COPY

In this program, our array is of length 5, but we’re trying to write a prime number into the 6th element (index 5).

C++ does _not_ do any checking to make sure that your indices are valid for the length of your array. So in the above example, the value of 13 will be inserted into memory where the 6th element would have been had it existed. When this happens, you will get undefined behavior -- for example, this could overwrite the value of another variable, or cause your program to crash.

Although it happens less often, C++ will also let you use a negative index, with similarly undesirable results.

!!! note "法则"

	When using arrays, ensure that your indices are valid for the range of your array!
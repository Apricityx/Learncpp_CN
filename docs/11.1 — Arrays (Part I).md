---
title: 11.1 - 数组（第一部分）
alias: 11.1 - 数组（第一部分）
origin: /arrays-part-i/
origin_title: "11.1 — Arrays (Part I)"
time: 2022-4-8
type: translation
tags:
- array
---

??? note "关键点速记"
	- 访问数组中的单个元素，需要使用数组名、下标操作符(`[]`)和下标(或索引)，下标从0开始计数
	- `int prime[5]{}; //初始化数组为0`

注意：这一章相对于前面几章会更有难度。如果你感泄气，一定要坚持住。好戏还在后面呢！


在 [[10.5 — Introduction to structs, members, and member selection|10.5 - 结构体、成员和成员选择]] 中，我们介绍了如何通过结构体将多种不同类型的数据聚合为一个变量。这项能力在我们需要对一个单独的对象进行建模时是很有用的。不过，当我们需要保存一系列相关的实例时，这个结构体就排不上用场了。


幸运的是，结构体并不是 C++ 中唯一能聚合数据的类型。**数组**可以将一系列具有相同类型的变量聚合为一个变量。


考虑这样一种情况，您想要记录一个班级 30 个学生的考试成绩。如果没有数组，你将不得不分配 30 个几乎相同的变量！

```cpp
// allocate 30 integer variables (each with a different name)
int testScoreStudent1{};
int testScoreStudent2{};
int testScoreStudent3{};
// ...
int testScoreStudent30{};
```

数组为我们提供了一种更简单的方法。下面的数组定义本质上与上面的代码是等价的:

```cpp
int testScore[30]{}; // allocate 30 integer variables in a fixed array
```

在数组变量声明中，我们使用方括号(`[]`)告诉编译器这是一个数组变量(而不是普通的变量)，以及分配多少变量(称为**数组长度**)。

在上面的例子中，我们声明了一个名为 `testScore` 的固定数组，长度为30。**固定数组**(也称为**固定长度数组**或**固定大小数组**)是在编译时已知长度的数组。`当testScore` 实例化时，将分配30个整数。

## 数组元素和下标

数组中的每个变量都被称为**元素**。元素没有自己的名称。而如果要访问数组中的单个元素，则需要使用数组名、下标操作符(`[]`)和一个被称为下标(或索引)的形参来告诉编译器需要哪个元素。这个过程被称为数组的取下标(subscripting)或索引(indexing)操作。

在上面的例子中，数组中的第一个元素是 `testScore[0]`。第二个是 `testScore[1]`。第十个是 `testScore[9]`。`testScore` 数组中的最后一个元素是`testScore[29]`。这很好，因为我们不再需要跟踪一堆不同的(但相关的)名称——我们只需改变下标来访问不同的元素。

**重要**：与日常生活中我们通常从1开始计数不同，在C++中，数组总是从0开始计数！

对于长度为 N 的数组，数组元素编号从0到N-1。这被称为数组的**范围**。


## 数组程序实例

下面是一个示例程序，将数组的定义和索引放在一起:

```cpp
#include <iostream>

int main()
{
    int prime[5]{}; // hold the first 5 prime numbers
    prime[0] = 2; // The first element has index 0
    prime[1] = 3;
    prime[2] = 5;
    prime[3] = 7;
    prime[4] = 11; // The last element has index 4 (array length-1)

    std::cout << "The lowest prime number is: " << prime[0] << '\n';
    std::cout << "The sum of the first 5 primes is: " << prime[0] + prime[1] + prime[2] + prime[3] + prime[4] << '\n';

    return 0;
}
```


打印结果为：

```
The lowest prime number is: 2
The sum of the first 5 primes is: 28
```

## 数组数据类型

数组可以由任何数据类型组成。在下面的例子中我们声明了一个`double`类型的数组：

```cpp
#include <iostream>

int main()
{
    double batteryLifeInHours[3]{}; // 分配 3 个 doubles
    batteryLifeInHours[0] = 2.0;
    batteryLifeInHours[1] = 3.0;
    batteryLifeInHours[2] = 4.3;

    std::cout << "The average battery life is " << (batteryLifeInHours[0] + batteryLifeInHours[1] + batteryLifeInHours[2]) / 3.0 << " hour(s)\n";

    return 0;
}
```

打印结果如下：

```
The average battery life is 3.1 hour(s)
```

数组也可以由结构体组成。考虑下面的例子：

```cpp
struct Rectangle
{
    int length{};
    int width{};
};
Rectangle rects[5]{}; // declare an array of 5 Rectangle
```

要访问数组中结构体元素的成员，首先选择想要访问的数组元素，然后使用成员选择操作符选择想要访问的成员：

```cpp
rects[0].length = 24;
```

数组甚至可以由数组组成，这个会在jin'h

Arrays can even be made from arrays, a topic that we’ll cover in a future lesson.

## Array subscripts

In C++, array subscripts must always be an integral type. This includes char, short, int, long, long long, etc… and strangely enough, bool (where false gives an index of 0 and true gives an index of 1). An array subscript can be a literal value, a variable (constant or non-constant), or an expression that evaluates to an integral type.

Here are some examples:

```cpp
int array[5]{}; // declare an array of length 5

// using a literal (constant) index:
array[1] = 7; // ok

// using an enum (constant) index
enum Animals
{
    animal_cat = 2
};
array[animal_cat] = 4; // ok

// using a variable (non-constant) index:
int index{ 3 };
array[index] = 7; // ok

// using an expression that evaluates to an integer index:
array[1+2] = 7; // ok
```

COPY

## Fixed array declarations

When declaring a fixed array, the length of the array (between the square brackets) must be a compile-time constant. This is because the length of a fixed array must be known at compile time. Here are some different ways to declare fixed arrays:

```cpp
// using a literal constant
int numberOfLessonsPerDay[7]{}; // Ok

// using a constexpr symbolic constant
constexpr int daysPerWeek{ 7 };
int numberOfLessonsPerDay[daysPerWeek]{}; // Ok

// using an enumerator
enum DaysOfWeek
{
    monday,
    tuesday,
    wednesday,
    thursday,
    friday,
    saturday,
    sunday,

    maxDaysOfWeek
};
int numberOfLessonsPerDay[maxDaysOfWeek]{}; // Ok

// using a macro
#define DAYS_PER_WEEK 7
int numberOfLessonsPerDay[DAYS_PER_WEEK]{}; // Works, but don't do this (use a constexpr symbolic constant instead)
```

COPY

Note that non-const variables or runtime constants cannot be used:

```cpp
// using a non-const variable
int daysPerWeek{};
std::cin >> daysPerWeek;
int numberOfLessonsPerDay[daysPerWeek]{}; // Not ok -- daysPerWeek is not a compile-time constant!

// using a runtime const variable
int temp{ 5 };
const int daysPerWeek{ temp }; // the value of daysPerWeek isn't known until runtime, so this is a runtime constant, not a compile-time constant!
int numberOfLessonsPerDay[daysPerWeek]{}; // Not ok
```

COPY

Note that in the last two cases, an error should result because the length is not a compile-time constant. Some compilers may allow these kinds of arrays (for C99 compatibility reasons), but they are invalid in C++, and should not be used in C++ programs. If your compiler allows these arrays, you probably forgot to disable compiler extensions (Lesson [0.10 -- Configuring your compiler: Compiler extensions](https://www.learncpp.com/cpp-tutorial/configuring-your-compiler-compiler-extensions/)).

## A note on dynamic arrays

Because fixed arrays have memory allocated at compile time, that introduces two limitations:

-   Fixed arrays cannot have a length based on either user input or some other value calculated at runtime.
-   Fixed arrays have a fixed length that can not be changed.

In many cases, these limitations are problematic. Fortunately, C++ supports a second kind of array known as a **dynamic array**. The length of a dynamic array can be set at runtime, and their length can be changed. However, dynamic arrays are a little more complicated to instantiate, so we’ll cover them later in the chapter.

## Summary

Fixed arrays provide an easy way to allocate and use multiple variables of the same type so long as the length of the array is known at compile time.

We’ll look at more topics around fixed arrays in the next lesson.
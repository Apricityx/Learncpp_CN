---
title: 4.18 - std::string_view 简介
alias: 4.18 - std::string_view 简介
origin: /introduction-to-stdstring_view/
origin_title: "4.18 — Introduction to std::string_view"
time: 2022-6-18
type: translation
tags:
- string_view
- C++
---

??? note "关键点速记"
	

考虑下面的程序：

```cpp
#include <iostream>

int main()
{
    int x { 5 };
    std::cout << x  << '\n';

    return 0;
}
```


当对 `x` 进行定义时，初始化值 5 会被拷贝到`int` `x`的内存地址。对于基础数据类型来说，初始化（或者拷贝）一个变量是很快的。

在看这个程序：

```cpp
#include <iostream>
#include <string>

int main()
{
    std::string s{ "Hello, world!" };
    std::cout << s << '\n';

    return 0;
}
```

当 `s` 初始化时，C 语言风格的字符串[[literals|字面量]]`"Hello, world!"` 会被拷贝到 `std::string s` 的内存地址。和基本数据类型不同的是，初始化或者拷贝`std::string` 是较慢的。

在上面的程序中，将 `s` 的值打印到控制台，然后销毁`s`。我们复制了一份“Hello, world!”，只是为了打印，然后就销毁了那个副本，相当低效。

下面这个例子也类似的情况：


```cpp
#include <iostream>
#include <string>

void printString(std::string str)
{
    std::cout << str '\n';
}

int main()
{
    std::string s{ "Hello, world!" };
    printString(s);

    return 0;
}
```

This example makes two copies of the C-style string “Hello, world!”: one when we initialize `s` in `main()`, and another when we initialize parameter `str`in `printString()`. That’s a lot of needless copying just to print a string!

## `std::string_view`（C++17）

为了解决 `std::string` 初始化或拷贝开销比较大的问题，C++17 引入了 `std::string_view` (存在于 `<string_view>` 头文件中)。`std::string_view` 为已有的字符串(C语言风格字符串、`std::string`或者字符数组) 提供一种**只读**的访问方式，而无需创建一份拷贝。

下面的程序和之前的程序效果是完全一致的，只不过我们使用`std::string_view`替换了`std::string`。

```cpp
#include <iostream>
#include <string>
#include <string_view>

void printSV(std::string_view str) // now a std::string_view
{
    std::cout << str '\n';
}

int main()
{
    std::string_view s{ "Hello, world!" }; // now a std::string_view
    printSV(s);

    return 0;
}
```


程序的输出结果和之前是完全一样的，但这个过程中并不会创建 “Hello, world!” 的副本。

`std::string_view s` with C-style string literal `"Hello, world!"`, `s` provides read-only access to “Hello, world!” without making a copy of the string. When we pass `s` to `printSV()`, parameter `str` is initialized from `s`. This allows us to access “Hello, world!” through `str`, again without making a copy of the string.

!!! success "最佳实践"

	Prefer `std::string_view` over `std::string` when you need a read-only string, especially for function parameters.

## constexpr `std::string_view`

Unlike `std::string`, `std::string_view` has full support for constexpr:

```cpp
#include <iostream>
#include <string_view>

int main()
{
    constexpr std::string_view s{ "Hello, world!" };
    std::cout << s << '\n'; // s will be replaced with "Hello, world!" at compile-time

    return 0;
}
```

COPY

Converting a `std::string` to a `std::string_view`

A `std::string_view` can be created using a `std::string` initializer, and a `std::string` will implicitly convert to a `std::string_view`:

```cpp
#include <iostream>
#include <string>
#include <string_view>

void printSV(std::string_view str)
{
    std::cout << str << '\n';
}

int main()
{
    std::string s{ "Hello, world" };
    std::string_view sv{ s }; // Initialize a std::string_view from a std::string
    std::cout << sv;

    printSV(s); // implicitly convert a std::string to std::string_view

    return 0;
}
```

COPY

Converting a `std::string_view` to a `std::string`

Because `std::string` makes a copy of its initializer, C++ won’t allow implicit conversion of a `std::string` from a `std::string_view`. However, we can explicitly create a `std::string` with a `std::string_view` initializer, or we can convert an existing `std::string_view` to a `std::string`using `static_cast`:

```cpp
#include <iostream>
#include <string>
#include <string_view>

void printString(std::string str)
{
    std::cout << str << '\n';
}

int main()
{
  std::string_view sv{ "balloon" };

  std::string str{ sv }; // okay, we can create std::string using std::string_view initializer

  // printString(sv);   // compile error: won't implicitly convert std::string_view to a std::string

  print(static_cast<std::string>(sv)); // okay, we can explicitly cast a std::string_view to a std::string

  return 0;
}
```

COPY

Literals for `std::string_view`

Double-quoted string literals are C-style string literals by default. We can create string literals with type `std::string_view` by using a `sv` suffix after the double-quoted string literal.

```cpp
#include <iostream>
#include <string>      // for std::string
#include <string_view> // for std::string_view

int main()
{
    using namespace std::literals; // easiest way to access the s and sv suffixes

    std::cout << "foo\n";   // no suffix is a C-style string literal
    std::cout << "goo\n"s;  // s suffix is a std::string literal
    std::cout << "moo\n"sv; // sv suffix is a std::string_view literal

    return 0;
};
```

COPY

Tip

The “sv” suffix lives in the namespace `std::literals::string_view_literals`. The easiest way to access the literal suffixes is via using directive `using namespace std::literals`. We discuss using directives in lesson [6.12 -- Using declarations and using directives](https://www.learncpp.com/cpp-tutorial/using-declarations-and-using-directives/). This is one of the exception cases where `using` an entire namespace is okay.

Do not return a std::string_view

Returning a std::string_view from a function is usually a bad idea. We’ll explore why in lesson [11.7 -- std::string_view (part 2)](https://www.learncpp.com/cpp-tutorial/stdstring_view-part-2/). For now, avoid doing so.
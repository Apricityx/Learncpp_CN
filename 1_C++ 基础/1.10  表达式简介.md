> [!INFO] 原文信息：
> - 链接：[1.10 — Introduction to expressions](https://www.learncpp.com/cpp-tutorial/introduction-to-expressions/)
> - 作者：[_ALEX_](https://www.learncpp.com/author/Alex/ "View all posts by Alex")  
> - 2022-2-17

# 1.10 表达式简介

## 表达式

考虑以下语句：

```cpp
// five() is a function that returns the value 5
int five()
{
    return 5;
}
int main()
{
    int a{ 2 };             // initialize variable a with literal value 2
    int b{ 2 + 3 };         // initialize variable b with computed value 5
    int c{ (2 * 3) + 4 };   // initialize variable c with computed value 10
    int d{ b };             // initialize variable d with variable value 5
    int e{ five() };        // initialize variable e with function return value 5

    return 0;
}
```

Each of these statements defines a new variable and initializes it with a value. Note that the initializers shown above make use of a variety of different constructs: literals, variables, operators, and function calls. Somehow, C++ is converting all of these different things into a single value that can then be used as the initialization value for the variable.

What do all of these have in common? They make use of an expression.

An expression is a combination of literals, variables, operators, and function calls that can be executed to produce a singular value. The process of executing an expression is called evaluation, and the single value produced is called the result of the expression.

When an expression is evaluated, each of the terms inside the expression are evaluated, until a single value remains. Here are some examples of different kinds of expressions, with comments indicating how they evaluate:

```cpp
2               // 2 is a literal that evaluates to value 2
"Hello world!"  // "Hello world!" is a literal that evaluates to text "Hello world!"
x               // x is a variable that evaluates to the value of x
2 + 3           // operator+ combines values 2 and 3 to produce value 5
x = 2 + 3       // 2 + 3 evaluates to value 5, which is then assigned to variable x
std::cout << x  // x evaluates to the value of x, which is then printed to the console
five()          // evaluates to the return value of function five()
```

COPY

As you can see, literals evaluate to their own values. Variables evaluate to the value of the variable. We haven’t covered function calls yet, but in the context of an expression, function calls evaluate to whatever value the function returns. And operators (such as operator+) let us combine multiple values together to produce a new value.

Note that expressions do not end in a semicolon, and cannot be compiled by themselves. For example, if you were to try compiling the expression _x = 5_, your compiler would complain (probably about a missing semicolon). Rather, expressions are always evaluated as part of statements.

For example, take this statement:

```cpp
int x{ 2 + 3 }; // 2 + 3 is an expression that has no semicolon -- the semicolon is at the end of the statement containing the expression
```

COPY

If you were to break this statement down into its syntax, it would look like this:

```cpp
type identifier { expression };
```

COPY

_Type_ could be any valid type (we chose _int_). _Identifier_ could be any valid name (we chose _x_). And _expression_ could be any valid expression (we chose _2 + 3_, which uses 2 literals and an operator).

Key insight

Wherever you can use a single value in C++, you can use an expression instead, and the expression will be evaluated to produce a single value.

Expression statements

Certain expressions (like _x = 5_) are useful by themselves. However, we mentioned above that expressions must be part of a statement, so how can we use these expressions by themselves?

Fortunately, we can convert any expression into an equivalent statement (called an expression statement). An expression statement is a statement that consists of an expression followed by a semicolon. When the statement is executed, the expression will be evaluated (and the result of the expression will be discarded).

Thus, we can take any expression (such as _x = 5_), and turn it into an expression statement (such as _x = 5;_) that will compile.

Note that we can make expression statements that compile but are meaningless/useless (e.g. _2 * 3;_). This expression evaluates to 6, and then the value 6 is discarded.

Rule

Values calculated in an expression are discarded at the end of the expression.
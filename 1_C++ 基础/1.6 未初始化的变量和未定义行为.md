## 未初始化的变量

不同于有些编程语言，C/C++ 并不会自动地将大部分变量初始化为某个给定值（例如0）。因此，当编译器为变量分配内存地址时，默认的初值将会是任何恰好位于该地址的值（垃圾值）。一个没有被明确赋予指定初值（通过初始化或赋值）的变量称为未初始化变量。

> [!NOTE] 作者注
> 很多读者想当然地认为，”初始化的“和"未初始化的"是一对严格的反义词，但实际上并不是。初始化意味着对象在被定义的时候即获得了一个给定的初始值。而未初始化则表示，对象没有被明确地指定任何值（通过各种途径，包括赋值）。因此，一个对象如果没有被”初始化“，但通过赋值得到了一个初值，它也不再是”未初始化“状态（因为它已经得到了一个值）
>  简单总结一下：
>  -  初始化：对象在被定义的同时也被赋予了初值
>  - 赋值：对象在定义后，被赋予了一个值
>  - 未初始化：对象始终没有能够获得一个明确指定的初值。

>[!INFO] 题外话
> This lack of initialization is a performance optimization inherited from C, back when computers were slow. Imagine a case where you were going to read in 100,000 values from a file. In such case, you might create 100,000 variables, then fill them with data from the file.
> 
> If C++ initialized all of those variables with default values upon creation, this would result in 100,000 initializations (which would be slow), and for little benefit (since you’re overwriting those values anyway).
> 
> For now, you should always initialize your variables because the cost of doing so is miniscule compared to the benefit. Once you are more comfortable with the language, there may be certain cases where you omit the initialization for optimization purposes. But this should always be done selectively and intentionally.

使用未初始化的变量的值，可能会带来难以预料的结果。以如下代码为例：

```cpp
#include <iostream>

int main()
{
    // define an integer variable named x
    int x; // this variable is uninitialized because we haven't given it a value

    // print the value of x to the screen
    std::cout << x; // who knows what we'll get, because x is uninitialized

    return 0;
}
```

在上面的例子中，计算机会为x分配某空闲的内存。该内存中存放的值会通过`std::cout`输出到控制台并打印，其打印出的结果可能是某个值（被当做整型来解析）。但究竟是什么值呢？答案是：”没有人知道“，或者说，每次运行程序，答案都可能是不一样的。作者在使用 Visual Studio 进行测试的时候，打印出的值是 `7177728`，再次运行时打印的值就编程了 `5277592`。你可以自己尝试并运行上述代码（不用担心，这并不会损坏你的电脑）。

>[!Warning] 注意
>Some compilers, such as Visual Studio, _will_ initialize the contents of memory to some preset value when you’re using a debug build configuration. This will not happen when using a release build configuration. Therefore, if you want to run the above program yourself, make sure you’re using a _release build configuration_ (see lesson [0.9 -- Configuring your compiler: Build configurations](https://www.learncpp.com/cpp-tutorial/configuring-your-compiler-build-configurations/) for a reminder on how to do that). For example, if you run the above program in a Visual Studio debug configuration, it will consistently print -858993460, because that’s the value (interpreted as an integer) that Visual Studio initializes memory with in debug configurations.

大多数的现代编译器都能够jian'cMost modern compilers will attempt to detect if a variable is being used without being given a value. If they are able to detect this, they will generally issue a compile-time error. For example, compiling the above program on Visual Studio produced the following warning:

`c:\VCprojects\test\test.cpp(11) : warning C4700: uninitialized local variable 'x' used`

If your compiler won’t let you compile and run the above program for this reason, here is a possible solution to get around this issue:

```cpp
#include <iostream>

void doNothing(int&) // Don't worry about what & is for now, we're just using it to trick the compiler into thinking variable x is used
{
}

int main()
{
    // define an integer variable named x
    int x; // this variable is uninitialized

    doNothing(x); // make the compiler think we're assigning a value to this variable

    // print the value of x to the screen (who knows what we'll get, because x is uninitialized)
    std::cout << x;

    return 0;
}
```


Using uninitialized variables is one of the most common mistakes that novice programmers make, and unfortunately, it can also be one of the most challenging to debug (because the program may run fine anyway if the uninitialized variable happened to get assigned to a spot of memory that had a reasonable value in it, like 0).

This is the primary reason for the “always initialize your variables” best practice.

## 未定义行为

Using the value from an uninitialized variable is our first example of undefined behavior. Undefined behavior (often abbreviated UB) is the result of executing code whose behavior is not well defined by the C++ language. In this case, the C++ language doesn’t have any rules determining what happens if you use the value of a variable that has not been given a known value. Consequently, if you actually do this, undefined behavior will result.

代码的未定义行为可能表现出如下症状：

-   程序每次运行都可能得到不同的结果；
-   程序每次运行都输出相同的错误结果；
-   程序每次运行的行为都不一致 (有时候结果正确，有时候不正确)；
-   程序看起来能够正确运行，但是一段时间后又会输出错误的结果；
-   程序崩溃退出，这种崩溃可能在程序启动后立即发生，也可能运行一段时间后发生；
-   程序经某些编译器编译后能够正常工作，但有些编译器则不行；
-   程序不能正常工作，直到你修改了某些看上毫不相干的代码。

或者，程序甚至能够正确运行并得到正确结果。所谓未定义行为，就是你永远不知道你能得到什么样的结果，无法预测每次运行的行为，也无法预测你做出某些修改后的影响。

在 C++ 中，如果你不够消息，那么产生未定义行为的途径有很多。我们会在后续的课程中遇到具体问题时进行讲解。请注意记录这些案例并切记要避免它们。

>[!TIP] 法则
>注意避免可能导致未定义行为的各种情况，例如使用未初始化变量。

> [!NOTE] 作者注
> 读者评论中最常见的问题之一便是：”你说不能这样做，但我偏偏这样做了，而且程序也能够正常运行！为什么？“
> 
>关于这个问题通常有两个答案。最常见的答案是，你的程序实际上表现出了未定义行为，只不过该未定义行为恰巧（暂时）输出了你期望的结果。改天（或者使用其他编译器、使用其他计算机）再运行时，可能未必如此。
>
>这个问题还可以这样回答。Alternatively, sometimes compiler authors take liberties with the language requirements when those requirements may be more restrictive than needed. For example, the standard may say, “you must do X before Y”, but a compiler author may feel that’s unnecessary, and make Y work even if you don’t do X first. This shouldn’t affect the operation of correctly written programs, but may cause incorrectly written programs to work anyway. So an alternate answer to the above question is that your compiler may simply be not following the standard! It happens. You can avoid much of this by making sure you’ve turned compiler extensions off, as described in lesson [0.10 -- Configuring your compiler: Compiler extensions](https://www.learncpp.com/cpp-tutorial/configuring-your-compiler-compiler-extensions/).

